<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongrongyu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Max&#39;s BigHouse">
<meta property="og:url" content="https://dongrongyu.github.io/index.html">
<meta property="og:site_name" content="Max&#39;s BigHouse">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Max">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dongrongyu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Max's BigHouse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Max's BigHouse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学有所依</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2021/03/02/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/02/%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/" class="post-title-link" itemprop="url">第5章-调优案例分析与实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-02 15:18:28" itemprop="dateCreated datePublished" datetime="2021-03-02T15:18:28+08:00">2021-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-03 11:28:08" itemprop="dateModified" datetime="2021-03-03T11:28:08+08:00">2021-03-03</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><h2 id="大内存硬件上程序部署策略"><a href="#大内存硬件上程序部署策略" class="headerlink" title="大内存硬件上程序部署策略"></a>大内存硬件上程序部署策略</h2><p>部署方式:</p>
<ul>
<li>一个单独的Java虚拟机实例管理大量Java堆内存</li>
<li>同时使用若干个Java虚拟机, 建立逻辑集群利用硬件资源</li>
</ul>
<h3 id="单个虚拟机实例"><a href="#单个虚拟机实例" class="headerlink" title="单个虚拟机实例"></a>单个虚拟机实例</h3><p>合理写代码, 尽量避免Full GC</p>
<p>面临问题:</p>
<ul>
<li>回收大块堆内存导致长时间停顿. 采用增量回收, G1, ZGC, Shenandoah</li>
<li>大内存必须使用64位Java虚拟机. 由于压缩至真, 处理器缓存行容量等因素, 性能低于32位虚拟机</li>
<li>应用必须稳定, 避免使用期间Full GC</li>
<li>相同程序在64位虚拟机占用空间更大 (压缩指针缓解)</li>
</ul>
<h3 id="逻辑集群方式部署"><a href="#逻辑集群方式部署" class="headerlink" title="逻辑集群方式部署"></a>逻辑集群方式部署</h3><p>在一台物理机器上启动多个应用服务器进程, 为每个服务器进程分配不同端口, 然后在前端搭建一个负载均衡器,以反向代理的方式来分配访问请求</p>
<p>面临问题:</p>
<ul>
<li>节点竞争全局资源, 如磁盘文件竞争</li>
<li>难高效利用资源池, 如连接池, 有些空闲有些繁忙</li>
<li>使用32位虚拟机的话, 收到内存限制</li>
<li>使用本地缓存的话, 内存浪费, 数据被缓存多份</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Redis设计与实现-单机数据库的实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 00:43:14" itemprop="dateCreated datePublished" datetime="2021-02-28T00:43:14+08:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-22 15:56:27" itemprop="dateModified" datetime="2021-08-22T15:56:27+08:00">2021-08-22</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  redisDb *db;   <span class="comment">// 一个数组, 保存服务器中的所有数据库</span></span><br><span class="line">  <span class="keyword">int</span> dbnum;     <span class="comment">// 服务器的数据库数量, 默认16. 初始化时, 根据创建dbnum个数据库</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	redisDb *db;   <span class="comment">// 记录客户端正在使用的数据库</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>
<p>SELECT命令: 显示的切换到一个数据库. 在执行FLUSHDB这样的危险命令前最好SELECT到需要执行FLUSHDB的目标数据库</p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228005024994.png" alt="image-20210228005024994"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  dict *dict;   <span class="comment">// 数据库键空间, 是一个字典, 保存着数据库中的所有键值对</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>键值对: 键+值</p>
<ul>
<li>键: 字符串对象</li>
<li>值: 字符串对象, 列表对象, 哈希表对象, 集合对象, 有序集合对象, 这些对象中的任一类型</li>
</ul>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228005612084.png" alt="image-20210228005612084"></p>
<h2 id="读写键空间的维护操作"><a href="#读写键空间的维护操作" class="headerlink" title="读写键空间的维护操作"></a>读写键空间的维护操作</h2><p>更新键空间的hit, miss次数. INFO status</p>
<p>更新键LRU</p>
<p>读取键时发现键过期, 则会先删除过期键再执行其他操作.</p>
<p>标记dirty: 如果有客户端WATCH某个键, 则修改后会标记dirty</p>
<p>增加dirty counter: 每次修改一个键后, 都会对脏键计数器的值增1</p>
<p>修改操作发送数据库通知: 开启了数据库通知时, 服务器将按配置发送相应的数据库通知</p>
<h2 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h2><p>服务器会自动删除生存时间TTL为0的键</p>
<p>设置过期时间方式, 这几个命令底层都是使用PEXPIREAT命令实现的:</p>
<ul>
<li><p>EXPIRE, PEXPIRE: 以s或者ms为精度为某个键设置TTL, 相对时间, 多长时间之后</p>
</li>
<li><p>EXPIREAT, PEXPIREAT: 以s或者ms设置过期时间戳</p>
</li>
</ul>
<p>TTL, PTTL: 返回键的剩余TTL</p>
<p>PERSIST: 移除一个键的过期时间</p>
<h2 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  dict *expire;   <span class="comment">// expire字典保存了数据库中所有键的过期时间</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>expire的键值对:</p>
<ul>
<li>键是一个指针, 指向某个数据库键对象 (和键空间字典的键指向同一个键对象)</li>
<li>值是一个long long类型的整数, 保存了数据库键的过期时间戳</li>
</ul>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228011531391.png" alt="image-20210228011531391"></p>
<h2 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h2><h3 id="三种删除策略"><a href="#三种删除策略" class="headerlink" title="三种删除策略"></a>三种删除策略</h3><ul>
<li>定时删除: 设置过期时间同时设置定时器, 在键过期时立即删除<ul>
<li>需要创建定时器, Redis时间事件采用无需链表, 查找时间复杂度O(N), 效率差</li>
<li>对内存友好, 对CPU不友好</li>
</ul>
</li>
<li>惰性删除: 每次从键空间获取键时, 检查是否过期, 过期则删除<ul>
<li>对CPU友好, 对内存不友好</li>
</ul>
</li>
<li>定期删除: 每隔一段时间, 对数据库进行一次检查, 删除全部或部分过期键<ul>
<li>定期执行, 并限制删除操作执行的时长和频率</li>
<li>难点在于执行时长和频率的设置</li>
</ul>
</li>
</ul>
<p>Redis结合使用了惰性删除和定期删除</p>
<h3 id="惰性删除流程"><a href="#惰性删除流程" class="headerlink" title="惰性删除流程"></a>惰性删除流程</h3><p>epireIfNeeded函数: 如果键过期则将键从数据库中删除</p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228160950463.png" alt="image-20210228160950463"></p>
<h3 id="定期删除策略流程"><a href="#定期删除策略流程" class="headerlink" title="定期删除策略流程"></a>定期删除策略流程</h3><p>每次运行, 都从一定数量的数据库中取出一定数量的随机键 (DEFAULT_KEY_NUMBERS) 进行检查, 并删除其中的过期键</p>
<p>current_db会记录当前activeExpireCycle函数检查的进度, 并在下一次activeExpireCycle函数调用时, 接着上一次的进度进行处理. 本次在10号db返回, 下次从11号db开始</p>
<p>所有数据库都检查过一遍后, current_db = 0, 开始新一轮的检查</p>
<h2 id="AOF-RDB和复制功能对过期键的处理"><a href="#AOF-RDB和复制功能对过期键的处理" class="headerlink" title="AOF, RDB和复制功能对过期键的处理"></a>AOF, RDB和复制功能对过期键的处理</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>保存RDB:</p>
<ul>
<li>已过期的键不会保存到RDB文件中</li>
</ul>
<p>载入RDB:</p>
<ul>
<li>主服务模式, 过期键不会被载入</li>
<li>从服务器模式, 过期键会被载入</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF文件写入: 过期键被惰性删除或定期删除后, 程序想AOF文件append一条DEL记录, 显示记录该键已被删除</p>
<p>AOF重写: 已过期的键不保存到重写的AOF文件</p>
<h4 id="复制-从服务器"><a href="#复制-从服务器" class="headerlink" title="复制 (从服务器)"></a>复制 (从服务器)</h4><p>只有收到主服务器的DEL命令才删除, 否则过期也不删除.</p>
<p>如果客户端请求过期键, 从服务器还是会返回客户端结果</p>
<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>客户端可以对某个数据库中的特定键进行订阅, 获取该键的执行情况 (SET, EXPIRE, DEL等)</p>
<p>类型:</p>
<ul>
<li><p>键空间通知: 某个键执行了什么命令</p>
<ul>
<li><p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228163051266.png" alt="image-20210228163051266"></p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228163155006.png" alt="image-20210228163155006"></p>
</li>
</ul>
</li>
<li><p>键事件通知: 某个操作被什么键执行了</p>
<ul>
<li><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228163209884.png" alt="image-20210228163209884"></li>
</ul>
</li>
</ul>
<p>notify-keyspace-events选项决定了服务器所发送通知的类型:</p>
<ul>
<li>AKE: 所有类型键空间通知和键事件通知</li>
<li>AK: 所有类型键空间通知</li>
<li>AE: 所有类型键事件通知</li>
<li>K$: 字符串键键空间通知</li>
<li>EI: 列表键键事件通知</li>
</ul>
<h3 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h3><p>由notify.c/notifyKeyspaceEvent函数实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event: 事件名称, key: 产生事件的键, dbid: 数据库号码</span></span><br><span class="line"><span class="comment">// type: 通知类型, REDIS_NOTIFY_SET集合键通知, REDIS_NOTIFY_GENERIC通用类型通知</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通知例子:</p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228164254419.png" alt="image-20210228164254419"></p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228164306088.png" alt="image-20210228164306088"></p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228164315172.png" alt="image-20210228164315172"></p>
<h4 id="通知函数的实现"><a href="#通知函数的实现" class="headerlink" title="通知函数的实现"></a>通知函数的实现</h4><ol>
<li>给定通知类型是否是服务器允许发送的类型server.notify_keyspace_events, 不是则直接返回</li>
<li>是否允许发送键空间通知, 允许则发送</li>
<li>是否允许发送键事件通知, 允许则发送</li>
</ol>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228164807639.png" alt="image-20210228164807639"></p>
<h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>RDB文件创建</p>
<ul>
<li>SAVE: 同步生成RDB文件, Redis服务器进程阻塞</li>
<li>BGSAVE: 派生一个子进程异步创建RDB文件, Redis服务器进程继续处理请求<ul>
<li>BGSAVE执行过程中, BGREWRITEAOF命令会被延迟到BGSAVE完成后执行</li>
<li>BGREWRITEAOF执行过程中, BGSAVE会被拒绝</li>
</ul>
</li>
</ul>
<p>RDB文件载入: 在启动时载入, 无特定命令</p>
<p>AOF更新频率比RDB高, 所以只有在关闭AOF时才使用RDB还原数据库</p>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228165935164.png" alt="image-20210228165935164"></p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228165949628.png" alt="image-20210228165949628"></p>
<h3 id="保存条件"><a href="#保存条件" class="headerlink" title="保存条件"></a>保存条件</h3><p>设置保存条件, 任意一条被满足就会触发:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1        &#x2F;&#x2F; 服务器在900s内, 对数据库进行了至少1次修改</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p>dirty计数器: 距离上一次成功执行SAVE或BGSAVE后, 进行了多少次修改</p>
<p>lastsave: 上一次成功执行SAVE或BGSAVE的时间戳</p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228170212541.png" alt="image-20210228170212541"></p>
<h3 id="检查条件是否满足"><a href="#检查条件是否满足" class="headerlink" title="检查条件是否满足"></a>检查条件是否满足</h3><p>serverCron默认100ms执行一次, 其中一项工作是检查save的条件是否满足</p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228170533691.png" alt="image-20210228170533691"></p>
<p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228170546608.png" alt="image-20210228170546608"></p>
<h2 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h2><p><img src="/2021/02/28/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20210228170611991.png" alt="image-20210228170611991"></p>
<p>REDIS: 固定REDIS这5个字符</p>
<p>db_version: 版本, 0006</p>
<p>databases: 0个或任意多个数据, 及库中的键值对</p>
<p>EOF: 1字节, 标识结束</p>
<p>check_sum: 对前4个部分计算的校验和</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis涉及与实现 - 数据结构与对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-19 23:20:54" itemprop="dateCreated datePublished" datetime="2021-02-19T23:20:54+08:00">2021-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-28 00:38:45" itemprop="dateModified" datetime="2021-02-28T00:38:45+08:00">2021-02-28</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis底层数据结构:</p>
<ul>
<li>SDS: 简单动态字符串, simple dynamic string</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>整数集合</li>
<li>压缩列表</li>
</ul>
<p>Redis的5种对象类型和底层数据结构的对应关系:</p>
<table>
<thead>
<tr>
<th>键类型</th>
<th>底层实现</th>
</tr>
</thead>
<tbody><tr>
<td>字符串对象</td>
<td>SDS</td>
</tr>
<tr>
<td>列表对象</td>
<td>压缩列表 (元素长度短且元素数量少时), 双端链表</td>
</tr>
<tr>
<td>哈希对象</td>
<td>压缩列表 (少量键值对且每个键值对键和值是小整数值或长度比较短的字符串), 字典</td>
</tr>
<tr>
<td>集合对象</td>
<td>整数集合 (元素均为整数值且数量不多时), 跳跃表</td>
</tr>
<tr>
<td>有序集合对象</td>
<td>压缩列表 (元素长度短且数量较少时), 跳跃表</td>
</tr>
</tbody></table>
<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>simple dynamic string, 简单动态字符串</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220005705662.png" alt="image-20210220005705662"></p>
<p>sizeof(buf) = len + free + 1</p>
<h2 id="空间重分配"><a href="#空间重分配" class="headerlink" title="空间重分配"></a>空间重分配</h2><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>SDS修改, 发生空间扩展</p>
<ul>
<li>扩展后 len &lt;  1MB: 预分配 free = len, sizeof(buf) = free + len + 1</li>
<li>扩展后 len &gt; 1MB: 预分配 free = 1MB, sizeof(buf) = len + free(1MB) + 1</li>
</ul>
<h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>SDS缩短时, 不立即释放空间.</p>
<p>SDS提供了相应的API, 在有需要时真正释放SDS</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>通过len记录长度而不是‘\0’</p>
<h2 id="相比C字符串的优点"><a href="#相比C字符串的优点" class="headerlink" title="相比C字符串的优点"></a>相比C字符串的优点</h2><ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><p>双向链表</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220233615752.png" alt="image-20210220233615752"></p>
<h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220232954579.png" alt="image-20210220232954579"></p>
<h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220233103318.png" alt="image-20210220233103318"></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>双端</li>
<li>无环</li>
<li>带表头和表尾指针</li>
<li>带链表长度计数器</li>
<li>多态: 值类型void* (可保存各种不同类型的值), dup、free、match函数可自定义</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h2><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210221234456492.png" alt="image-20210221234456492"></p>
<h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220234550734.png" alt="image-20210220234550734"></p>
<p>dictType: 一簇用于操作特定类型键值对的函数, Redis为不同用途的字典设置不同类型的特定函数</p>
<p>privdata: 需要传给类型特定函数的可选参数</p>
<h4 id="dictType"><a href="#dictType" class="headerlink" title="dictType"></a>dictType</h4><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210221234415105.png" alt="image-20210221234415105"></p>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220234445307.png" alt="image-20210220234445307"></p>
<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220234521971.png" alt="image-20210220234521971"></p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>为了让哈希表负载因子维持在一个合理范围, 字典可能进行扩展和收缩, 进行rehash</p>
<p>负载因子: load_factor = ht[0].used / ht[0].size</p>
<p>步骤:</p>
<ol>
<li>为ht[1]分配空间<ul>
<li>扩展: h[1]的大小为第一个大于等于ht[0].used*2的2^n</li>
<li>收缩: h[1]的大小为第一个大于等于ht[0].used的2^n</li>
</ul>
</li>
<li>h[0]的元素rehash到h[1]上</li>
<li>所有元素rehash完成后, 释放h[0], h[0] = h[1], h[1]创建一张空表</li>
</ol>
<p>扩展和收缩的条件:</p>
<ol>
<li>服务器没有执行BGSAVE或BGREWRITEAOF, 负载因子大于等于1</li>
<li>服务器在执行BGSAVE或BGREWRITEAOF, 负载因子大于等于5</li>
<li>负载因子小于0.1时执行收缩操作</li>
</ol>
<p>渐进式rehash:</p>
<ul>
<li>字典每次的添加、删除、查找、更新操作时, 将ht[0]中rehashidx索引上的键值对rehash到ht[1]中, 且rehashidx++</li>
<li>rehash完成时rehashidx设为-1</li>
<li>rehash的操作负载均摊到每个CRUD操作中, 避免单次计算量过大</li>
<li>rehash过程中的CUD操作会同时检索ht[0]和ht[1]</li>
</ul>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>平均O(logN)、最坏O(N)的节点查找</p>
<h2 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h2><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210222000803717.png" alt="image-20210222000803717"></p>
<p>level: 层数最大节点的层数</p>
<p>length: 跳跃表的长度, 表头节点不计</p>
<h3 id="zskiplistNode"><a href="#zskiplistNode" class="headerlink" title="zskiplistNode"></a>zskiplistNode</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210222001104268.png" alt="image-20210222001104268"></p>
<p>层: 每创建一个节点, 根绝幂次定律, 随机生成一个介于1~32的值最为level数组的大小, 也即层的高度</p>
<p>跨度: 两个节点之间的距离, 计算节点在跳跃表中的排位 (rank)</p>
<p>后退指针: 不指向表头节点</p>
<p>score: 用于节点间的比较. 多个节点<strong>可以相同</strong></p>
<p>obj: 指向一个字符串对象, 字符串对象保存一个SDS值. <strong>必须唯一</strong></p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>intset, 集合中不会重现重复元素</p>
<p>元素类型: int16_t、int32_t或int64_t</p>
<p>元素按从小到大的顺序在contents中存储</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210222012539715.png" alt="image-20210222012539715"></p>
<h2 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h2><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210222011545836.png" alt="image-20210222011545836"></p>
<p>encoding: INTSET_ENC_INT16, INTSET_ENC_INT32, INTSET_ENC_INT64</p>
<p>元素实际类型由encoding决定, 并不保存int8_t</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>新元素类型比现有类型要大时, 需要升级</p>
<p>复杂度O(N)</p>
<p>步骤: </p>
<ol>
<li>根绝新元素类型, 扩展整数集合, 并为新元素分配空间</li>
<li>将所有元素转成和新元素相同类型, 从后往前放到新空间上</li>
<li>添加新元素</li>
<li>length++</li>
</ol>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210222012556585.png" alt="image-20210222012556585"></p>
<p>整数集合只支持升级不支持降级</p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>节省内存, 连续内存块组成的顺序型结构, 每个节点可以保存一个字节数组或者一个整数值</p>
<h2 id="结构-5"><a href="#结构-5" class="headerlink" title="结构"></a>结构</h2><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210224004646363.png" alt="image-20210224004646363"></p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210224004656656.png" alt="image-20210224004656656"></p>
<h3 id="节点结构-1"><a href="#节点结构-1" class="headerlink" title="节点结构"></a>节点结构</h3><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210224005253997.png" alt="image-20210224005253997"></p>
<h4 id="content"><a href="#content" class="headerlink" title="content"></a>content</h4><p>字节数组或者整数值 </p>
<ul>
<li><p>字节数组</p>
<ul>
<li>长度小于等于63 (2^6-1)的字节数组</li>
<li>长度小于等于16383 (2^14-1)</li>
<li>长度小于等于4294967295 (2^32-1)</li>
</ul>
</li>
<li><p>整数值</p>
<ul>
<li>4位长, 0~12间的无符号整数</li>
<li>1字节的有符号整数</li>
<li>3字节的有符号整数</li>
<li>int16_t</li>
<li>int32_t</li>
<li>Int64_t</li>
</ul>
</li>
</ul>
<h4 id="previous-entry-length"><a href="#previous-entry-length" class="headerlink" title="previous_entry_length"></a>previous_entry_length</h4><p>1字节或者5字节, 记录前一个节点的长度</p>
<ul>
<li>1字节: 前一个节点长度小于254</li>
<li>5字节: 前一个节点长度大于等于254, 第一个节点设置为0xFE (254), 之后四个字节保存长度</li>
</ul>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210225010124103.png" alt="image-20210225010124103"></p>
<p>前一个节点的起始地址 = 当前节点的起始地址 - previous_entry_length</p>
<p>利用该字段压缩列表可以实现从表尾向表头的遍历</p>
<h4 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h4><p>记录content保存数据的类型和长度</p>
<ul>
<li>字节数组编码: 1字节, 2字节或5字节, 最高位00, 01, 10开头</li>
<li>整数编码: 该字段1字节, 最高位以11开头, 类型和长度由剩余6位决定</li>
</ul>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210225010818422.png" alt="image-20210225010818422"></p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>添加和删除在特定情况下, 会引发所有节点长度的更新, 引发N次重分配, 每次重分配最坏复杂度位O(N), 所以连锁更新最坏复杂度位O(N^2)</p>
<ul>
<li><p>添加情况下的连锁更新: 所有节点e1~eN长度都为250~253字节之间, 在表头添加一个长度大于254的节点, 则所有节点都需要扩展</p>
</li>
<li><p>删除情况下的连锁更新: 节点排列big, small, e1~eN, e1~eN长度介于250~253, small小于254, big大于等于254. 删除small引发e1~eN的连锁更新</p>
</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>Redis对象种类: 字符串对象, 列表对象, 哈希对象, 集合对象, 有序集合对象</p>
<p>对象的实现基于前文的基本数据结构, 且同一个对象在不同场景可能会采取不同的底层结构</p>
<p>对象系统基于引用计数内存回收. 在适当条件下多个数据库建会共享同一快内存</p>
<p>对象带有访问时间记录</p>
<p>Redis键值对: 建对象 (字符串对象) + 值对象</p>
<h2 id="结构-6"><a href="#结构-6" class="headerlink" title="结构"></a>结构</h2><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226002243394.png" alt="image-20210226002243394"></p>
<p>键对象一定为字符串对象, 值对象可以为字符串对象, 列表对象, 哈希对象, 集合对象或者有序集合对象中的一种</p>
<h3 id="encoding-1"><a href="#encoding-1" class="headerlink" title="encoding"></a>encoding</h3><p>各个对象类型对应的底层实现:</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226003249831.png" alt="image-20210226003249831"></p>
<p>对象类型 (TYPE命令的输出):</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226002559898.png" alt="image-20210226002559898"></p>
<p>编码对应的底层数据结构 (OBJECT ENCODING的输出):</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226003431546.png" alt="image-20210226003431546"></p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226003456329.png" alt="image-20210226003456329"></p>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><ul>
<li>int: 保存整数值, 且可以用long表示 (void*转换成long)<ul>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226003808306.png" alt="image-20210226003808306"></li>
</ul>
</li>
<li>raw: 字符串值, 且长度大于32字节, 使用SDS存储<ul>
<li>两次内存分配, 分别分配redisObject和sdshdr结构</li>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226003940391.png" alt="image-20210226003940391"></li>
</ul>
</li>
<li>embstr: 字符串值, 且长度小于等于32字节<ul>
<li>一次内存分配, redisObject和sdshdr存储在一块连续的空间</li>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226004231224.png" alt="image-20210226004231224"></li>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210226004248255.png" alt="image-20210226004248255"></li>
</ul>
</li>
</ul>
<p>浮点数在Redis中也作为字符串存储, 且编码为embstr或raw</p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>转换方向:</p>
<ul>
<li><p>int -&gt; raw</p>
</li>
<li><p>embstr -&gt; raw</p>
</li>
</ul>
<p>转换情况:</p>
<ul>
<li>int值追加了字符串, int -&gt; raw</li>
<li>对embstr (只读)进行修改, embstr -&gt; raw</li>
</ul>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><h3 id="编码格式-1"><a href="#编码格式-1" class="headerlink" title="编码格式"></a>编码格式</h3><ul>
<li><p>ziplist: 压缩列表, 每个entry存储一个列表元素</p>
<ul>
<li><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227174824402.png" alt="image-20210227174824402"></p>
<p>三个元素: 1, “three”, 5</p>
</li>
</ul>
</li>
<li><p>linkedlist: 双端链表</p>
<ul>
<li><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227175048068.png" alt="image-20210227175048068"></p>
<p>链表底层对象是字符串对象 (字符串对象是Redis五种类型对象中唯一一种可能被嵌套的对象类型)</p>
</li>
</ul>
</li>
</ul>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>使用ziplist编码的情况:</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节</li>
<li>元素数量小于等于512个</li>
</ul>
<p>其他情况将转为使用linkedlist编码</p>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><h3 id="编码格式-2"><a href="#编码格式-2" class="headerlink" title="编码格式"></a>编码格式</h3><ul>
<li><p>ziplist: 压缩列表. 键值对保存成两个entry存储在相邻位置</p>
<ul>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227180908219.png" alt="image-20210227180908219"></li>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227181005751.png" alt="image-20210227181005751"></li>
</ul>
</li>
<li><p>hashtable: 字典. 字典的</p>
<ul>
<li>键值对的键和值都是字符串对象</li>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227181758646.png" alt="image-20210227181758646"></li>
</ul>
</li>
</ul>
<h3 id="编码转换-2"><a href="#编码转换-2" class="headerlink" title="编码转换"></a>编码转换</h3><p>使用ziplist编码:</p>
<ul>
<li>所有键值对的键和值的字符串长度都小于64字节 (可配置hash-max-ziplist-value)</li>
<li>键值对数量小于等于512个 (可配置hash-max-ziplist-entries)</li>
</ul>
<p>其他情况转换为使用hashtable</p>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><h3 id="编码格式-3"><a href="#编码格式-3" class="headerlink" title="编码格式"></a>编码格式</h3><ul>
<li>intset: 整数集合<ul>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227224940968.png" alt="image-20210227224940968"></li>
</ul>
</li>
<li>hashtable: 字典, 每个键是一个字符串对象, 值为NULL<ul>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227224959524.png" alt="image-20210227224959524"></li>
</ul>
</li>
</ul>
<h3 id="编码转换-3"><a href="#编码转换-3" class="headerlink" title="编码转换"></a>编码转换</h3><p>使用intset编码:</p>
<ul>
<li>所有元素都是整数值</li>
<li>元素数量不超过512个 (可配置set-max-intset-entries)</li>
</ul>
<p>其他情况则转换为hashtable</p>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><h3 id="编码格式-4"><a href="#编码格式-4" class="headerlink" title="编码格式"></a>编码格式</h3><ul>
<li><p>ziplist: 压缩列表. 两个相邻节点来保存, 元素成员 + 分值</p>
<ul>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227225500171.png" alt="image-20210227225500171"></li>
<li><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227225509830.png" alt="image-20210227225509830"></li>
</ul>
</li>
<li><p>skiplist: 使用zset作为作为底层实现, zset包含一个字典和跳跃表. </p>
<ul>
<li><pre><code class="c">typedef struct zset &#123;
    zskiplist *zsl;
  dict *dict;
&#125;
</code></pre>
</li>
<li><p>zsl跳跃表: 节点object保存元素的成员, score保存了元素的分值</p>
</li>
<li><p>dict: 成员到分值的映射, O(1)复杂度查找成员的分值</p>
</li>
<li><p>zsl和dict通过指针共享相同元素的成员和分值 (分值是double应该是不需要共享的)</p>
</li>
<li><p>成员是字符串对象, 分值是一个double类型的浮点数</p>
</li>
<li><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227232410389.png" alt="image-20210227232410389"></p>
</li>
<li><p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227232456947.png" alt="image-20210227232456947"></p>
</li>
<li><p>上图中没有展现出共享成员, 实际上zsl和dict是共享成员的</p>
</li>
</ul>
</li>
</ul>
<h3 id="编码转换-4"><a href="#编码转换-4" class="headerlink" title="编码转换"></a>编码转换</h3><p>使用ziplist编码:</p>
<ul>
<li>所有元素长度都小于64字节 (zset-max-ziplist-value)</li>
<li>元素数量小于128个 (zset-max-ziplist-entries)</li>
</ul>
<p>其他情况转换为skiplist编码</p>
<h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>针对命令执行的对象命令可分为两种类型:</p>
<ul>
<li>通用命令: 对任何类型的键执行<ul>
<li>DEL, EXPIRE, RENAME</li>
</ul>
</li>
<li>类型特定命令: 一些命令只能对特定类型的键执行<ul>
<li>只能对字符串键执行: SET, GET, APPEND, STRLEN等</li>
<li>只能对哈希键执行: HDEL, HSET, HGET, HLEN等</li>
<li>只能对列表键执行: RPUSH, LPOP, LINSERT, LLEN等</li>
<li>集合键: SADD, SPOP, SINTER, SCARD等</li>
<li>有序集合键: ZADD, ZCARD, ZRANK, ZSCORE</li>
</ul>
</li>
</ul>
<h3 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h3><p>类型特定命令的类型检查是通过redisObject结构的type属性来实现的</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227233523722.png" alt="image-20210227233523722"></p>
<h3 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h3><p>多态命令类型:</p>
<ul>
<li>基于类型的多态: 一个命令能同时处理多种不同类型的键, 如DEL, EXPIRE, TYPE等</li>
<li>基于编码的多态: 一个命令能同时用于处理多种不同编码, 如LLEN等</li>
</ul>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227233842418.png" alt="image-20210227233842418"></p>
<h3 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h3><p>Reidis基于引用计数技术实现的内存回收</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227233929371.png" alt="image-20210227233929371"></p>
<p>引用计数变化形式:</p>
<ul>
<li>创建一个新对象, refcount = 1</li>
<li>对象被一个新程序使用, refcount++</li>
<li>对象不再被一个程序使用, refcount–</li>
<li>refcount == 0, 对象被释放</li>
</ul>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>基于refcount实现对象共享.</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210227234333432.png" alt="image-20210227234333432"></p>
<p>Redis在初始化服务器时, 会创建一万个整数值字符串对象 (0~9999). (可修改redis.h/REDIS_SHARED_INTEGERS)</p>
<p>Redis支队包含整数值的字符串进行共享 (感觉应该也只有初始化的整形字符串对象才被共享)</p>
<h3 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h3><p>对象最后一次被命令访问的时间 = 当前时间 - lru时间</p>
<p><img src="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210228002000143.png" alt="image-20210228002000143"></p>
<p>如果服务器打开了maxmemory选项, 且内存回收算法为volatile-lru或allkeys-lru, 那么空转时间较长的那部分键会优先被服务器释放</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/11/23/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-11-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-11-14/" class="post-title-link" itemprop="url">Redis设计与实现 Chapter 11-14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 12:26:53 / 修改时间：13:13:05" itemprop="dateCreated datePublished" datetime="2020-11-23T12:26:53+08:00">2020-11-23</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>AOF通过保存所有修改数据库的<strong>写命令请求</strong>来记录服务器数据库状态</p>
<p>以Redis<strong>命令请求协议</strong>的格式保存</p>
<p>写命令 -&gt; AOF缓冲区 -&gt; 同步写入到AOF文件</p>
<p>appendfsync选项:</p>
<ul>
<li>always: 写入 + 同步</li>
<li>everysec: 写入 + 每秒同步</li>
<li>no: 仅写入不同步, 同步依赖操作系统</li>
</ul>
<p>服务器启动后载入数据优先通过AOF文件</p>
<p>AOF重写:</p>
<ul>
<li>重写后文件体积更小</li>
<li>通过读取数据库中的键值对实现, 并不是读原有AOF文件</li>
</ul>
<p>执行BGWRITEAOF命令:</p>
<ul>
<li>期间维护一个AOF重写缓冲区, 记录重写过程中服务器执行的写命令</li>
<li>重写执行完后, AOF重写缓冲区中的内容追加到新AOF文件末尾, 使新旧文件保存的数据库状态一致</li>
<li>用新AOF文件替换旧文件</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>类型:</p>
<ul>
<li><p>文件事件:</p>
<ul>
<li>对socket的抽象, 套接字变为acceptable、writable、readable状态时, 相应文件事件就会产生</li>
<li>基于Reactor模式实现的网络通信程序</li>
<li>AE_READABLE和AE_WRITABLE事件</li>
</ul>
</li>
<li><p>时间事件:</p>
<ul>
<li>定时事件、周期性事件</li>
<li>一般情况下只执行serverCron函数一个时间事件 (但这个函数执行了很多内容)</li>
<li>事件loop中, 先处理文件事件, 后处理时间事件. 处理过程中不抢占</li>
</ul>
</li>
</ul>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>clients链表连接了多个客户端状态, 新增加的客户端添加到链表末尾</p>
<p>客户端关闭情况:</p>
<ul>
<li>网络连接关闭</li>
<li>发送了不合协议格式的命令请求</li>
<li>CLIENT KILL</li>
<li>空转事件超时</li>
<li>输出缓冲区大小超出限制</li>
</ul>
<p>伪客户端:</p>
<ul>
<li>处理Lua脚本的伪客户端: 初始化创建, 一直存在</li>
<li>载入AOF文件的伪客户端: 载入工作创建, 完成后关闭</li>
</ul>
<p>flags标识客户端的角色和状态</p>
<p>输入缓冲区记录命令请求, 大小不能超过1GB</p>
<p>命令参数和参数个数纪录在argv和argc</p>
<p>cmd指向RedisCommand, 记录命令实现函数</p>
<p>输出缓冲区:</p>
<ul>
<li>固定大小缓冲区, 16KB</li>
<li>可变大小缓冲区, StringObject链表, 不能超过限制值<ul>
<li>硬性限制: 超过则关闭连接</li>
<li>软性限制: 一定时间内一直超过则关闭</li>
</ul>
</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>命令请求从发送到完成的步骤:</p>
<ol>
<li>客户端发请求给服务器</li>
<li>server读取命令, 解析命令参数</li>
<li>根据命令查找实现函数, 执行命令并得出命令回复</li>
<li>server将命令回复返回给客户端</li>
</ol>
<p>serverCron: 每100ms执行一次</p>
<ul>
<li>更新服务器状态信息</li>
<li>处理SIGTERM信号</li>
<li>管理客户端资源和数据库状态</li>
<li>检查并执行持久化操作</li>
<li>…</li>
</ul>
<p>服务器初始化步骤:</p>
<ul>
<li>初始化服务器状态</li>
<li>initServerConfig, 载入服务器配置, 创建命令表</li>
<li>initServer, 初始化服务器数据结构: server.clients客户端状态链表, server.db数据库数组, server.pubsub_channels频道订阅信息的字典, server.pubsub_patterns模式订阅信息的链表、server.lua用于执行Lua脚本的Lua环境, server.slowlog用于保存满查询日志的属性</li>
<li>还原数据库状态: AOF、RDB</li>
<li>执行事件循环: 文件事件 + 时间时间</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/11/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-8-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-8-10/" class="post-title-link" itemprop="url">Redis设计与实现 Chapter 8-10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 11:52:56" itemprop="dateCreated datePublished" datetime="2020-11-09T11:52:56+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-23 12:27:09" itemprop="dateModified" datetime="2020-11-23T12:27:09+08:00">2020-11-23</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>五种对象类型, 美中至少有两种以上的编码方式, 优化在不同场景的使用效率</p>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>编码方式</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>字符串对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>列表对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>哈希对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集合对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>有序集合对象</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>服务器在执行命令之前, 会检查给定键的<strong>值对象类型</strong>能否执行指定的命令</p>
<p>内存回收通过<strong>引用计数</strong>实现</p>
<p>Redis只共享整数类型的字符串对象, 初始化时设置, 默认为0~9999</p>
<p>redistObject中的<strong>lru属性</strong>用于记录最后一次被访问的时间, 这个时间可以用于计算空转时间</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>redisServer.db存储所有的数据库, redisServer.dbnum属性保存数据库数量</p>
<p>客户端SELECT命令修改数据库, 让它指向redistServer.db中的不同元素来切换数据库</p>
<p>数据库主要有两个字典构成:</p>
<ul>
<li>dict: 保存数据库的所有键值对</li>
<li>expires: 保存键的过期时间, 键只想dict中的某个键, 值是过期时间</li>
</ul>
<p>数据库健总是一个字符串对象, 值可以是字符串对象、哈希表对象、集合对象、列表对象、有序集合对象</p>
<p>Redist过期健删除策略: 惰性删除 + 定期删除</p>
<p>SAVE和BGSVAE命令产生的新RDB文件不会包含已过期的键</p>
<p>过期键被删除后, 会追加一条DEL命令到AOF文件末尾</p>
<p>主服务器删除一个过期键后, 会向所有 从服务器发送一条DEL命令</p>
<p>从服务器发现过期键也不会删除</p>
<p>当Redis对数据库进行修改后, 会根据配置向客户端发送数据库通知</p>
<h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>RDB用于存储和还原Redis服务器中所有键值对数据</p>
<p>保存数据库到RDB:</p>
<ul>
<li>SAVE指令, 阻塞服务器进程保存数据库</li>
<li>BGSAVE指令: 生成子进程保存数据库, 不会阻塞服务器. 期间<ul>
<li>SAVE命令被拒绝</li>
<li>BGSAVE命令被拒绝</li>
<li>不能和BGREWRITEAOF同时执行, BGREWRITEAOF会被延迟到BGSAVE结束后执行</li>
</ul>
</li>
</ul>
<p>save选项设置服务器自动保存的条件</p>
<ul>
<li>save 300 10</li>
</ul>
<p>RDB是一个经过压缩的二进制文件, 不同类型的键值对以不同的方式来保存</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/10/26/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-1-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/26/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-1-7/" class="post-title-link" itemprop="url">Redis设计与实现 Chapter 1-7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-26 10:26:40 / 修改时间：13:14:05" itemprop="dateCreated datePublished" datetime="2020-10-26T10:26:40+08:00">2020-10-26</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p>数据库健总是一个字符串对象</p>
<p>数据库值的五种类型:</p>
<ul>
<li>字符串对象 string object</li>
<li>列表对象 list object</li>
<li>哈希对象 hash object</li>
<li>集合对象 set object</li>
<li>有序集合对象 sorted set object</li>
</ul>
<table>
<thead>
<tr>
<th>应用</th>
<th>底层实现</th>
</tr>
</thead>
<tbody><tr>
<td>列表键</td>
<td>链表</td>
</tr>
<tr>
<td>哈希键, Redis数据库的底层实现, CRUD</td>
<td>字典</td>
</tr>
<tr>
<td>有序集合键</td>
<td>跳表</td>
</tr>
<tr>
<td>集合键 (只包含整数)</td>
<td>整数集合</td>
</tr>
<tr>
<td>列表键、哈希键</td>
<td>压缩列表</td>
</tr>
</tbody></table>
<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p>Redis使用简单动态字符串 simple dynamic string (SDS)作为默认字符串实现</p>
<p>优点:</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存充分配次数<ul>
<li>空间预分配<ul>
<li>分配后len&lt;1MB, free = len</li>
<li>len &gt;= 1MB, free = 1MB</li>
</ul>
</li>
<li>惰性空间释放</li>
</ul>
</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>list结构 + listNode结构</p>
<p>双端链表</p>
<p>无环链表: 表头节点的前置指针和表尾节点的后置指针都指向NULL</p>
<p>值可以为不同类型: void *</p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>每个字典带有两个hash表, ht[1]在rehash时使用</p>
<p>用于哈希键和数据库时, 采用MurmurHash2算法</p>
<p>链地址法解决冲突</p>
<p>rehash过程采用渐进式, 将rehash的操作负载平分到每次操作上</p>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>zskiplist + zskiplistNode</p>
<p>每个跳跃节点的层高时1~32之间的随机数</p>
<p>score (double类型)可重复, 但是obj (字符串对象)必须唯一</p>
<p>score相同时, 按obj字符串的字典序排序</p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>有序、无重复</p>
<p>自动升级: 集合元素从后往前扩展并迁移到新地址</p>
<p>升级操作的优点: 更加灵活、节约内存</p>
<p>不支持降级操作</p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>为节约内存而开发的顺序型数据结构</p>
<p>每个节点可以保存一个字节数组或整数值</p>
<p>增、删节点又可能引发连锁更新, 但这种操作通常更新的节点数量不多且发生概率不高</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/10/20/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">第4章-虚拟机性能监控、故障处理工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-20 22:26:55" itemprop="dateCreated datePublished" datetime="2020-10-20T22:26:55+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-22 15:57:51" itemprop="dateModified" datetime="2021-08-22T15:57:51+08:00">2021-08-22</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h1><h1 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h1><p>四个工具: JConsole、JHSDB、VisualVM、JMC</p>
<p>JConsole: JDK 5</p>
<p>JHSDB: JDK 9, 之前可以通过sa-jdi.jar包引入</p>
<p>VisualVM: JDK 6 Update 7, 已经从JDK中剥离, 但仍可以免费下载、使用</p>
<p>Java Mission Control: JDK 7 Update 40开始随JDK发布, JDK 11转入OpenJDK管理, 需要结合HotSpot Java Flight Recorder (JFR, 收费), 所以是OracleJDK商业特性</p>
<h2 id="JHSDB"><a href="#JHSDB" class="headerlink" title="JHSDB"></a>JHSDB</h2><p>jhsdb hsdb –pid 11180    // 启动jhsdb</p>
<p>scanoops 0x00007f32c7800000 0x00007f32c7b50000 JHSDB_TestCase$ObjectHolder       // 查找虚地址范围内JHSDB_TestCase$ObjectHolder实例的地址</p>
<p>revptrs 0x00007f32c7a7c458     // 搜索引用该地址的对象实例</p>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>基于JMX (Java Management Extensions) 的可视化监视, 管理工具, 通过JMX的MBean (Managed Bean) 对系统进行信息收集和参数动态调整. 运用于虚拟机或虚拟机之上的软件中.</p>
<p>提供内存 jstat, 线程 jstak 的执行数据</p>
<h2 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h2><p>运行监视, 故障处理, 性能分析 (Profiling)</p>
<p><img src="/2020/10/20/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/image-20210302150653905.png" alt="image-20210302150653905"></p>
<p>主要插件:</p>
<ul>
<li>Btrace动态日志跟踪: 不中断目标程序前提下, 动态加入原本并不存在的调试代码<ul>
<li>基于Java虚拟机的Instrument (是Java Virtual Machine Interface, JVMTI的重要组件)开发, 提供了一整套Agent机制.</li>
<li>阿里的Arthas也是基于Instrument实现了类似的功能</li>
</ul>
</li>
</ul>
<h2 id="Java-Mission-Control"><a href="#Java-Mission-Control" class="headerlink" title="Java Mission Control"></a>Java Mission Control</h2><p>可持续在线监控工具, 展示虚拟机MBean和JFR的数据</p>
<p>结合JFR (一套内建在HotSpot虚拟机的监控和基于时间的信息搜集框架, 过程式收集)使用, 采用JMX协议通信.</p>
<h1 id="Hotspot虚拟机插件及工具"><a href="#Hotspot虚拟机插件及工具" class="headerlink" title="Hotspot虚拟机插件及工具"></a>Hotspot虚拟机插件及工具</h1><p>Ideal Graph Visualizer, Client Compiler Visualizer, MakeDeps, Project Creator, LogCompilation, HSDIS</p>
<h2 id="HSDIS"><a href="#HSDIS" class="headerlink" title="HSDIS"></a>HSDIS</h2><p>HotSpot虚拟机即使编译代码反汇编插件</p>
<p>搭配JITWatch, 对程序执行过程反汇编, 展示汇编代码, 字节码, 反汇编java代码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">第3章-垃圾收集器和内存分配策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 23:30:26" itemprop="dateCreated datePublished" datetime="2020-09-22T23:30:26+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-02 00:05:31" itemprop="dateModified" datetime="2021-03-02T00:05:31+08:00">2021-03-02</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>程序计数器、虚拟机栈、本地方法栈分配内存在编译期可知, 随着方法结束或线程结束内存被回收</p>
<p>Java堆和方法区的内存分配具有不确定性, 是内存分配与回收的主要讨论方面</p>
<h1 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死?"></a>对象已死?</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>Reference counting, 每个对象用一个计数器来判断对象的存活情况</p>
<p>需要许多额外工作保证该算法正确的工作, 譬如: 难以处理对象之间循环引用的问题</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过GC Roots中的根对象作为起始节点, 从这些节点开始建立对象的引用链. 如果对象没有一条路径到达GC Roots, 则这个对象是不可达的.</p>
<p>该算法被用于Java、C#、Lisp等语言的内存管理</p>
<p>GC Roots的对象:</p>
<ul>
<li><strong>虚拟机栈</strong> (栈帧中的本地变量表) 中引用的对象, 如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li><strong>方法区中类静态属性引用的对象</strong>, 如Java类的引用类型静态变量</li>
<li><strong>方法区中常量引用的对象</strong>, 如字符串常量池中的引用</li>
<li><strong>本地方法栈JNI (Native方法)引用的对象</strong></li>
<li><strong>Java虚拟机内部的引用</strong>, 如基本数据类型的Class对象, 一些常驻的异常对象, 比如NullPointerException、OutOfMemoryError等</li>
<li><strong>所有被同步锁 (Synchronized关键字) 持有的对象</strong></li>
<li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>根据垃圾收集器的不同, 还有其他对象“临时性”的加入. 如针对Java堆的某一块区域的垃圾收集需要考虑是否与其他区域关联 (记忆集)</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>强引用Strong Reference: 代码中存在的引用关系, 即Object obj = new Object(), 垃圾收集器永远不会收集强引用对象</p>
<p>软引用SoftReference: 系统要发生溢出异常前会将这些对象列进回收范围进行回收, 如果还没有足够空间才会抛出内存溢出异常. SoftReference来实现</p>
<p>弱引用WeakReference: 只能生存到下一次垃圾收集发生. WeakReference类来实现</p>
<p>虚引用: 不对对象生存时间构成影响, 只为了在对象被收集时得到一个系统通知. PhantomReference类来实现</p>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡?"></a>生存还是死亡?</h2><p>对象销毁的两次标记过程:</p>
<ol>
<li>可达性分析后发现没有与GC Roots相连接的引用链</li>
<li>如果没有覆盖finalize()方法或finalize()方法已经被调用过, 只会被<u>调用一次</u></li>
</ol>
<p>如果需要执行finalize()方法, 对象将被放入F-Queue的队列中, 之后由虚拟机自动建立的、<strong>低调度优先级</strong>的Finalizer线程去执行. 虚拟机会触发刚方法的运行, 但不一定会等待它运行结束(防止长时间等待).</p>
<p>finalize()中若重新和引用链进行关联, 则可以不被回收 (只可逃脱一次), 如:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200924102412342.png" alt="image-20200924102412342"></p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区(HotSpot虚拟机中的元空间或者永久代)的回收比较严苛, 《Java虚拟机规范》并不要求方法区必须实现垃圾回收</p>
<p>主要回收: 废弃的常量、不再使用的类型</p>
<p>废弃常量的条件: 如字符串“java”进入常量池但没有任何对象引用该常量, 虚拟机也没有引用</p>
<p>不再使用的类条件: </p>
<ul>
<li>该类的所有实例或其派生子类的实例都已被回收</li>
<li>加载该类的类加载器已经被回收 (通常很难达成, 除非是经过精心设计的可替换类加载器的场景如OSGi、JSP的重加载等)</li>
<li>该类对应的java.lang.Class对象没有再任何地方被引用 (无法在任何地方通过反射访问该类的方法)</li>
</ul>
<p>大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景中, 需要JVM具备类型卸载能力, 以免对方法区造成过大内存压力</p>
<p>VM args:</p>
<ul>
<li>-Xnoclassgc: 控制虚拟机是否对类型进行回收</li>
<li>-verbose:class、-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息 (-XX:+TraceClassUnLoading需要FastDebug版虚拟机)</li>
</ul>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>两种方法: 引用计数式垃圾收集Reference Counting GC、追踪式垃圾收集Tracing GC, 也被称为直接式垃圾收集和间接式垃圾收集</p>
<p>本节内容均属于追踪式</p>
<h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>基于两个假说+一个用于解决跨代引用问题的经验法则:</p>
<ul>
<li>弱分代假说Weak Generatioal Hypothesis: 绝大多数对象都是朝生夕灭的</li>
<li>强分代假说Strong Generation Hypothesis: 熬过越多次垃圾收集过程的对象越难以消亡</li>
<li>跨带引用假说Intergenerational Reference Hypothesis: 跨带引用相对于同代引用来说仅占极少数</li>
</ul>
<p>新生代Young Generation: 每次收集会有大批对象死去, 每次回收后存活的少量对象, 将会逐步晋升到老年代中存放</p>
<p>老年代Old Generation: </p>
<p>依据跨带引用假说, 为了解决跨代引用问题, 需要在新生代上建立一个全局的数据结构记忆集Remembered Set</p>
<ul>
<li>该结构把老年代划分成若干小块, 标识出老年代哪一块内存会存在跨代引用, 此后Minor GC时需要将这些对象加入GC Roots</li>
<li>在对象改变引用关系时需要维护数据正确性</li>
</ul>
<p>一些GC名词:</p>
<ul>
<li>部分收集Partial GC, 目标不是收集整个Java堆的GC<ul>
<li>新生代收集Minor GC/Young GC</li>
<li>老年代收集Major GC/Old GC: 目前只有CMS收集器存在Old GC</li>
<li>混合收集Mixed GC: 目标是收集整个新生代和部分老年代的GC, 只有G1收集器有这种行为</li>
</ul>
</li>
<li>整堆收集Full GC: 收集整个Java堆和方法区</li>
</ul>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>Mark-Sweep算法, 包括标记+清除两个阶段</p>
<p>可以标记需要GC的对象也可以标记存活的对象, 然后执行清除需要GC的对象</p>
<p>缺点:</p>
<ul>
<li>执行效率不稳定. 如果Java堆中包含大量对象, 且大部分需要被回收, 这时标记和清除两个过程的执行效率随对象数量的增长大大降低</li>
<li>内存碎片化</li>
</ul>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>解决标记-清除算法存在的问题</p>
<p>将内存区域划分为相等的两块, GC时将存活的对象复制到另一块半区, 同时清理之前用的半区</p>
<p>该算法被主流的商用Java虚拟机新生代GC采用</p>
<p>Appel式回收 (Andrew Appel 1989年提出) 的Hotspot实现:</p>
<ul>
<li>一个Eden区+两个Survivor区</li>
<li>Eden和Survivor空间大小比例8:1</li>
<li>每次GC时将Eden区和Survivor区中存活的对象复制到另一块Survivor区中</li>
<li>每次新生代可用内存空间为容量的90%</li>
<li>分配担保Handle Promotion: 当Survivor空间不足以容纳一次Minor GC的存活对象时, 这些对象将直接进入老年代</li>
</ul>
<p>缺点:</p>
<ul>
<li>对象存活率高时需要较多复制操作, 不适用于老年代</li>
</ul>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>Mark-Compact算法, 类似标记-清除算法, 但是会将存活对象整理存放到一起解决内存碎片问题.</p>
<p>相比Mark-Sweep算法的优缺:</p>
<ul>
<li>GC时间长, 包括内存的复制过程</li>
<li>没有内存碎片问题</li>
<li>Mark-Sweep算法在内存碎片导致无法分配大对象时可能采取“分区空闲分配链表” 解决内存分配问题 (类似于磁盘存储大文件), 会是的分配和访问效率低. Mark-Compact则没这个问题</li>
</ul>
<p>一些垃圾收集器可能会结合使用Mark-Sweep和Mark-Compact</p>
<h1 id="HotSpot算法细节实现"><a href="#HotSpot算法细节实现" class="headerlink" title="HotSpot算法细节实现"></a>HotSpot算法细节实现</h1><h2 id="根结点枚举"><a href="#根结点枚举" class="headerlink" title="根结点枚举"></a>根结点枚举</h2><p>GC Roots节点主要为全局性引用 (常量或类静态属性)与执行上下文(栈帧的本地变量表)</p>
<p>根结点枚举的过程必须暂停用户线程</p>
<p>虚拟机其实并不需要一个不漏的从方法区等GC Roots获取哪些地方存放着对象引用的, 虚拟机是可以直接得到哪些地方存放着对象引用的. HotSpot通过OopMap (Ordinary Object Pointer)记录, 在类加载动作完成, 会把对象什么偏移量上是什么类型的数据计算出来, 即使是即时编译, 也会在某个位置记录下栈里和寄存器哪些位置是引用.</p>
<p>???不太懂</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928195908139.png" alt="image-20200928195908139"></p>
<p>OopMap是针对指令的数据结构, 会为某条特定位置的指令生成</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>Safepoint, 用于生成OopMap的特定位置, 也是发生GC的指令位置, 避免对每条指令生成造成过多存储空间浪费. 设立不能太短也不能太长</p>
<p>安全点的选取以“是否具有让程序长时间执行的特征”为标准, 例如方法调用、循环跳转、异常跳转等指令序列复用的位置</p>
<p>让所有线程(其实不包括JNI调用的线程)跑到安全点停下的方式:</p>
<ul>
<li>抢先式中断Preemptive Suspension, 现有虚拟机一般不采用<ul>
<li>垃圾收集式, 系统让用户线程全部中断, 如果发现有用户线程不在安全点上则恢复其执行过一会再中断, 直到跑到安全点</li>
</ul>
</li>
<li>主动式中断Voluntary Suspension<ul>
<li>设一个标志位, 各个线程执行过程中不断轮训, 一旦发现标志位true则再最近安全点上主动挂起</li>
<li>轮询位置: 安全点 + 所有创建对象和其他需要再Java堆上分配内存的地方</li>
<li>HotSpot使用内存保护陷阱方式实现<ul>
<li>一条汇编指令</li>
<li>预先注册异常处理器, 需要用户线程暂停时置0x160100内存页为不可读, test指令则发生自陷异常信号, 线程挂起等待</li>
<li><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928234101400.png" alt="image-20200928234101400"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>Safe Region, 引用关系不会发生变化的代码片段, 虚拟机可以不需要等待在安全区域中的线程</p>
<p>用于避免线程处于Sleep状态或Blocked状态的情况</p>
<p>线程离开安全区域时, 需要检查虚拟机是否完成了根节点枚举(或暂停其他用户线程的阶段), 如果还未完成则需等待信号, 否则直接继续执行.</p>
<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><p>记忆集Remembered Set: 用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
<p>记录精度:</p>
<ul>
<li>非收集区域的所有跨代引用对象数组, 空间占用和维护成本高<ul>
<li><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120232896.png" alt="image-20200929120232896"></li>
</ul>
</li>
<li>字长精度: 精确到一个机器字长, 记录该字包含跨代指针</li>
<li>对象精度: 精确到一个对象, 该对象有跨代指针的字段</li>
<li>卡精度: 一块内存区域, 改区域内有对象含有跨代指针</li>
</ul>
<p>卡精度为最常用的记忆集实现方式, 通过卡表Card Table方式实现记忆集.</p>
<p>卡表: </p>
<ul>
<li><p>字节数组</p>
<ul>
<li>CARD_TABLE [this address &gt;&gt; 9] = 0;</li>
</ul>
</li>
<li><p>如果卡页中有对象存在跨代引用, 则标识为1</p>
</li>
<li><p>每个元素都对应标识内存区域一块特定大小的内存块(卡页), 如上代表2^9=512字节</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120706248.png" alt="image-20200929120706248"></p>
</li>
</ul>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>写屏障Write Barrier: 维护卡表状态的技术, 可以看作虚拟机层面对“引用类型字段赋值”的AOP操作, 这个操作会被编译器放到每一个赋值操作之中.</p>
<p>对引用对象赋值产生一个Around通知, 执行额外动作. 又分为写前屏障Pre-Write Barrier和写后屏障Post-Write Barrier. 除了G1收集器, 其他收集器都只用到了写后屏障</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929154351247.png" alt="image-20200929154351247"></p>
<p>写屏障会带来赋值时的额外开销, 不过相比Minor GC扫描整个老年代要低得多</p>
<p>伪共享问题False Sharing: 多个线程对属于同一Cache line的卡表元素操作时由于缓存一致性同步导致的性能降低</p>
<p>伪共享问题可通过修改前判断来降低影响</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929155628297.png" alt="image-20200929155628297"></p>
<p>VM args:</p>
<ul>
<li>-XX:+UseCondCardMark: 用来决定是否开启卡表更新的条件判断</li>
</ul>
<h2 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h2><p>用户线程和收集器并发工作带来的问题:</p>
<ul>
<li>原本消亡的对象标记为存活. 可以容忍</li>
<li>原本存活的对象标记为消亡 (对象消失). 不可产生</li>
</ul>
<p>三色标记:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929160844578.png" alt="image-20200929160844578"></p>
<p>“对象消失” 的条件 (1994, Wilson):</p>
<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ol>
<p>“对象消失”的解决方案:</p>
<ul>
<li>增量更新(Incremental Update): 破坏条件一, 黑色对象插入白色对象引用时, 将这个新插入的引用记录下来, 收集结束后, 再将这些引用关系中的黑色对象标记为灰色, 重新扫描一次</li>
<li>原始快照(Snapshot At The Beginning): 破坏条件二, 灰色对象要删除指向白色对象的引用关系时, 记录这个删除的引用, 在扫描结束时, 将这些对象标记为灰色, 重新扫描. 其实就是按刚开始扫描的引用结构搜索</li>
</ul>
<p>增量更新: CMS</p>
<p>原始快照: G1、Shenandoah</p>
<h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><p>“经典” : &gt;=JDK 7 Update 4, &lt;JDK11</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929162601589.png" alt="image-20200929162601589"></p>
<p>JDK 9时图中两种收集器组合被废弃</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>最基础的、历史悠久的收集器. 仍是HotSpot虚拟机运行在客户端模式下的默认新生代收集器</p>
<p>单线程收集器, 工作时必须暂停其他所有工作线程</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929164608367.png" alt="image-20200929164608367"></p>
<p>优缺:</p>
<ul>
<li>简单而高效</li>
<li>额外内存消耗少</li>
<li>单核处理器或核心数少的环境来说, 比较高效</li>
<li>适用于桌面应用场景和部分微服务应用</li>
</ul>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器的多线程并行版本, 除了GC时候使用多线程, 其余都和Serial相同</p>
<p>新生代收集器</p>
<p>ParNew + Serial Old:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929165537962.png" alt="image-20200929165537962"></p>
<p>主要在JDK 5中用于和CMS搭配使用</p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>新生代收集器, 使用标记-复制算法, 和ParNew类似</p>
<p>Parallel Scavenge收集器主要关注吞吐量, 又称为吞吐量收集器, 目的在于控制垃圾收集时间占程序总执行时间的比例.</p>
<p>自适应调节策略(GC Ergonomics)来动态调整Java堆上各个分代空间的分配</p>
<p>VM args:</p>
<ul>
<li>-XX:MaxGCPauseMills: 一次GC允许的最长时间的ms.</li>
<li>-XX:GCTimeRatio: 允许的最大垃圾收集时间比例, 设定为x时, 最大垃圾收集时间占总时间的1/(1+x)</li>
<li>-XX:+UseAdaptiveSizePolicy: 自适应调节策略, 启用后不再需要指定新生代大小(-Xmn)、Eden与Survivor的比例(-XX:SurvivorRatio)、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数, Parallel Scavenge收集器会根据运行时监控信息动态调整以提供<u>最合适的停顿时间</u>和<u>最大的吞吐</u></li>
</ul>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial的老年代版本, 单线程收集器, 使用标记-整理算法</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929173655549.png" alt="image-20200929173655549"></p>
<p>使用场景:</p>
<ul>
<li>客户端模式的HotSpot虚拟机使用</li>
<li>&lt;=JDK 5时搭配Parallel Scavenge收集器使用</li>
<li>CMS发生Concurrent Mode Failure时使用</li>
</ul>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>JDK 6提供, Parallel Scavenge收集器的老年代版本, 并发收集, 使用标记-整理算法</p>
<p>主要用于和Parallel Scavenge的搭配使用</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929174133829.png" alt="image-20200929174133829"></p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS (Concurrent Mark Sweep)以获取最短回收停顿时间为目标的收集器, 使用标记-清除算法. 总体上来说为并发收集器</p>
<p>执行步骤:</p>
<ol>
<li>初始标记 (CMS initial mark)</li>
<li>并发标记 (CMS cocurrent mark)</li>
<li>重新标记 (CMS remark)</li>
<li>并发清除 (CMS concurrent sweep)</li>
</ol>
<p>其中1、3需要停顿用户线程, 通常3执行时间大于1, 2、4耗时时间最长</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929175220239.png" alt="image-20200929175220239"></p>
<p>三个明显缺点:</p>
<ul>
<li>处理器资源敏感: 默认回收线程数为(处理器核心数+3)/4, 核心数&gt;4时, 占用约为25%的处理器运算资源, &lt;4时影响较大. 增量式并发收集器i-CMS使得用户线程可以和垃圾收集线程在一个核心交替执行缓解该问题, 但效果不好在JDK 9废弃</li>
<li>无法处理“浮动垃圾” (FLoating Garbage), 出现“Concurrent Mode Failure”: 由于2、4阶段用户线程在运行可能产生垃圾, 如果预留的内存空间无法满足分配新对象的需求, 会出现“Concurrent Mode Failure”, 此时会启用Serial Old收集器执行一次暂停用户线程执行GC.</li>
<li>内存碎片: Mark-Sweep算法导致, 无法分配时会导致Full GC. Full GC需要完全停止用户线程执行. 可以通过两个参数调节</li>
</ul>
<p>VM args:</p>
<ul>
<li>-XX:CMSInitiatingOccupancyFraction: 执行CMS时老年代的使用空间比例</li>
<li>-XX:+UseCMSCopmpactAtFullCollection: 在FUll GC时进行内存整理, JDK 9废弃</li>
<li>-XX:CMSFullGCsBeforeCompation: 执行若干次不整理空间的Full GC后, 下一次进入Full GC前会先进行碎片整理, 默认为0. JDK 9废弃</li>
</ul>
<h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>G1收集器, JDK 7提出. JDK 9替代Parallel Scavenge+Parallel Old组合成为默认收集器, CMS成为Deprecate, 但由于历史遗留, 规划在JDK 10提出“统一垃圾收集器接口”.</p>
<p>基于Region的堆内存布局:</p>
<ul>
<li>连续的Java堆被划分成多个大小相等的独立区域Region, 每个Region都可以根据需要扮演新生代的Eden空间、Survivor空间或者老年代空间</li>
<li>Humongous区域: <ul>
<li>专门用来存储大对象, G1大多数行为都把Humongous Region作为老年代的一部分来看待.</li>
<li>只要大小超过一个Region容量的一半则可视为大对象</li>
<li>超过整个Region容量的超级大对象, 会放在N个连续的Humongous Region之中</li>
<li>-XX:G1HeapRegionSize: 1MB~32MB, 每个region的大小</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20210301212011316.png" alt="image-20210301212011316"></p>
<p>G1收集器对内存任何部分组成的回收集Collection Set (CSet) 来进行回收, 不再针对分代, 而是哪块内存的垃圾数量多, 回收收益最大</p>
<p>G1对扮演不同角色的Region采用不同的策略去处理</p>
<p>G1是一个“<strong>停顿时间模型</strong>”的收集器</p>
<ul>
<li>建立起可预测的停顿时间模型是因为以Region为单次回收的最小单元</li>
<li>每次收集的内存空间都是Region大小的整数倍</li>
<li>避免在整个Java堆中进行全区域垃圾收集</li>
<li>依赖垃圾堆积的“价值”大小建立<strong>优先级列表</strong>, 在允许的停顿时间 (-XX:MaxGCPauseMillis) 内优先处理收益最大的Region</li>
<li>“价值”: 回收所获的的空间大小以及回收所需时间的经验值</li>
</ul>
<p>G1设计的细节问题:</p>
<ul>
<li>跨Region的引用对象如何解决: <ul>
<li>每个region维护自己的记忆集, 这些记忆集记录别的region指向自己的卡页范围.</li>
<li>G1记忆集的实现通过一个哈希表, Key是别的Region的起始地址, Value是一个集合, 里面存储的元素是卡表的索引号.</li>
<li>Region数量比传统分代数量多的多, G1至少要耗费Java堆容量的10%~20%额外内存来维持收集器工作</li>
</ul>
</li>
<li>收集线程如何与用户线程并发执行:<ul>
<li>G1通过原始快照SATB算法来实现</li>
<li>每个Region有两个TAMS (Top at Mark Start) 指针, 新分配对象地址必须在这两个指针位置以上, 即它们是默认存活不纳入回收范围</li>
<li>如果回收速度赶不上分配速度, 也会导致Full m GC冻结用户线程执行</li>
</ul>
</li>
<li>怎样建立可靠的停顿预测模型:<ul>
<li>-XX:MaxGCPauseMillis: 指定停顿时间</li>
<li>G1会统计每个Region的回收耗时、每个Region记忆集里脏卡数量等各个可测量步骤花费的成本, 分析得出衰减平均值 (更准确代表“最近”的平均状态)、标准偏差、置信度等统计信息, 通过这些信息预测现在开始回收哪些Region组成的回收集可以在不超过期望停顿时间内获得最高的收益</li>
</ul>
</li>
</ul>
<p>G1收集器的四个步骤:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930004721338.png" alt="image-20200930004721338"></p>
<p>只有在并发标记阶段是并发的, G1的主要目标时间延迟可控的情况下获得尽可能高的吞吐, “全功能收集器”</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930005222909.png" alt="image-20200930005222909"></p>
<p>停顿时间设置的过小会使得回收赶不上内存分配导致Full GC</p>
<p>G1设计上更注重能够应付内存分配速率 (Allocation Rate) 而不追求一次把Java堆全部清理干净</p>
<p>G1和CMS对比:</p>
<ul>
<li>G1可以指定对打停顿时间、分Region内存布局、通过“价值”确定回收集</li>
<li>G1收集不会产生内存碎片, CMS会因内存碎片导致Full GC</li>
<li>G1内存占用和执行负载高</li>
<li>G1每个Region都需要一个卡表, CMS只有新生代有一个卡表. 都通过写后屏障维护</li>
<li>G1使用原始快照搜索SATB算法, 写前屏障来实现指针引用的变化, 避免最终标记阶段时间过长. CMS通过增量算法. 增量算法为什么不需要写前屏障呢???</li>
<li>G1写屏障操作复杂, 放入队列进行异步处理. CMS写屏障同步处理</li>
</ul>
<p>通常CMS在小内存上表现会优于G1, 大内存上G1性能更好</p>
<h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><p>Red hat写的收集器, Oracle G1收集器的继承者, 只在OpenJDK中包含, 被OracalJDK通过条件编译排除</p>
<p>为程序执行提供低延迟的GC停顿时间, 高运行负担情况下吞吐量低于G1、CMS和Parallel Scavenge. 据表3-2的测试结果</p>
<p>相比G1:</p>
<ul>
<li>基于Region的对内存管理</li>
<li>支持并发的整理算法</li>
<li>不使用分代收集 (并不是说分代收集对Shenandoah没有价值)</li>
<li>使用连接矩阵(Connection Matrix), 而不是用G1的记忆集实现方式</li>
</ul>
<p>连接矩阵Connection Matrix: 降低了记忆集维护消耗, 也降低了伪共享问题</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019153724892.png" alt="image-20201019153724892"></p>
<p>步骤:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160542645.png" alt="image-20201019160542645"></p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160603709.png" alt="image-20201019160603709"></p>
<p><strong>三个重要阶段</strong>: 并发标记、并发回收、并发引用更新</p>
<p>工作流程:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019161007965.png" alt="image-20201019161007965"></p>
<h3 id="Brooks-Pointer"><a href="#Brooks-Pointer" class="headerlink" title="Brooks Pointer"></a>Brooks Pointer</h3><p>原始的转发指针操作实现:</p>
<ul>
<li>步骤:<ol>
<li>在被移动对象的原有内存上设置Memory Protection Trap</li>
<li>访问旧对象时的内存空间时产生自陷中断, 调用异常处理器</li>
<li>将代码访问转发到复制后的新对象上</li>
</ol>
</li>
<li>缺点: 如果没有操作系统支持, 这种方案导致用户态频繁切换到核心态, 代价高</li>
</ul>
<p>Brooks Pointer (Forward Pointer):</p>
<ul>
<li><p>方案: </p>
<ul>
<li>在对象头部增加Brooks Pointer</li>
<li>没有Memory Protection Trap的问题, 但是对像访问多了一次间接跳转</li>
</ul>
</li>
<li><p>对象未被移动时:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019162035357.png" alt="image-20201019162035357"></p>
</li>
<li><p>被移动后:</p>
</li>
</ul>
<p>并发写Brooks Pointer:</p>
<ul>
<li><p>问题:</p>
<ol>
<li><p>收集器线程复制了对象</p>
</li>
<li><p>用户线程更新对象某个字段     –&gt; 写在旧对象上</p>
</li>
<li><p>收集器线程更新转发指针的引用为新副本地址</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019170904557.png" alt="image-20201019170904557"></p>
</li>
</ol>
</li>
<li><p>解决方式: Shenandoah收集器通过CAS保证并发对象访问的正确性</p>
</li>
</ul>
<p>为了实现Brooks Pointer, Shenandoah在读、写屏障中都加入了额外的转发处理</p>
<p>基于引用访问屏障 Load reference Barrier:</p>
<ul>
<li>为了减少读屏障对访问带来的问题, 计划在JDK 13中引入</li>
<li>只拦截对象中数据类型为引用类型的读写操作, 而不去管原生数据类型等其他非引用字段的读写</li>
</ul>
<h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>PGC和G4收集器的继承者</p>
<p>ZGC特征:</p>
<ul>
<li>基于Region内存布局</li>
<li>(暂时)不设分代</li>
<li>使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法</li>
<li>以低延迟为首要目标</li>
</ul>
<p>ZGC的Region (Page、ZPage): 具有动态性 (动态创建和销毁、动态容量大小)</p>
<ul>
<li>Small Region: 2MB, 放置&lt;256KB的小对象</li>
<li>Medium Region: 32MB, 放置&gt;=256KB但&lt;4MB的对象</li>
<li>Large Region: 容量动态变化, 为2MB的整数倍. 放置4MB及以上的<u>一个</u>大对象 (所以large region可能小于medium region). 由于拷贝开销大, Large region在ZGC中不会被重分配</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019182007284.png" alt="image-20201019182007284"></p>
<h3 id="染色指针-Colored-Pointer、Tag-Pointer、Version-Pointer"><a href="#染色指针-Colored-Pointer、Tag-Pointer、Version-Pointer" class="headerlink" title="染色指针 (Colored Pointer、Tag Pointer、Version Pointer)"></a>染色指针 (Colored Pointer、Tag Pointer、Version Pointer)</h3><p>在对象引用上记录信息的一项技术</p>
<p>64位系统 -&gt; AMD架构只支持48位虚地址空间 -&gt; 64位Linux支持47位虚地址空间和46位物理地址空间</p>
<p>46位地址空间仍然过剩, 所以取高4位来存储四个标志信息:</p>
<ul>
<li>对象三色标记状态</li>
<li>是否进入了重分配集 (即被移动过)</li>
<li>是否只能通过finalize()方法才能访问到</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019183401317.png" alt="image-20201019183401317"></p>
<p>缺点:</p>
<ul>
<li>4TB的内存限制</li>
<li>不能支持32位平台</li>
<li>不能支持压缩指针(-XX:+UseCompressedOops)</li>
<li>……</li>
</ul>
<p>优势:</p>
<ul>
<li>Region存活对象被移走之后, 这个Region能立即释放, 而不用等到整个堆中所有指向该Region的引用都被修正</li>
<li>大幅减少读、写屏障的使用量. 使用内存屏障目的时记录对象引用变化情况, 但这些信息直接维护在指针中了. ZGC只使用了读屏障 (原因是染色指针和不支持分代) </li>
<li>可以作为一种扩展结构记录更多与对象标记、重定位过程相关的数据, 用以提高性能. 譬如记录低频访问对象, 转移到不常访问的内存区域</li>
</ul>
<p>多重映射 (Multi-Mapping):</p>
<ul>
<li>LInux/x86-64平台上ZGS使用多重映射将不同的虚拟地址映射到同一物理地址上</li>
<li>多重映射技术是怎么实现的呢???</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019195358982.png" alt="image-20201019195358982"></p>
<h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005314958.png" alt="image-20201020005314958"></p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005346874.png" alt="image-20201020005346874"></p>
<p>理解: </p>
<ul>
<li>并发标记阶段的GC Roots应该不包括跨region的指针. 在并发预备重分配中会扫描其他所有region来定位跨region指针指向重分配集中的对象.</li>
<li>重分配的时候应该对对象的所有引用指针进行染色, 这个过程应该是原子操作的, 应该也会造成停顿时间???</li>
</ul>
<h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><p>没有使用记忆集、分代, 因此不需要写屏障, 但GC时间长, 能承受的对象分配速率不会太高 (解决该问题的根本方法是分代收集, 针对新生代进行更频繁、更快的收集)</p>
<p>NUMA-aware的内存分配. 在ZGA之前只有Parallel Scavenge支持NUMA-aware内存分配</p>
<p>GC过程低延迟, 吞吐量也比较高能达到Parallel Scavenge的90% (根据图3-23结果)</p>
<h1 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h1><h2 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h2><p>JDK 10开始, 为了隔离垃圾收集器与Java虚拟机解释、编译、监控等子系统的关系, RedHat提出了垃圾收集的统一接口, Epsilon是这个接口的有效性验证和参考实现</p>
<p>不干活的收集器</p>
<p>用于剥离垃圾收集器影响的性能测试和压力测试</p>
<p>用于不需要垃圾收集就会推出的极小应用</p>
<h2 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h2><h2 id="虚拟机及垃圾收集器日志"><a href="#虚拟机及垃圾收集器日志" class="headerlink" title="虚拟机及垃圾收集器日志"></a>虚拟机及垃圾收集器日志</h2><p>JDK 9之后所有日志都可以利用-Xlog参数统一输出格式</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220853939.png" alt="image-20201020220853939"></p>
<p>日志支持的所有模块:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220910121.png" alt="image-20201020220910121"></p>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><h1 id="实战-内存分配与回收策略"><a href="#实战-内存分配与回收策略" class="headerlink" title="实战: 内存分配与回收策略"></a>实战: 内存分配与回收策略</h1><p>概念上来讲, 对象应该都在堆上分配 (实际上可能经过即时编译后被拆散成标量类型并间接地在栈上分配)</p>
<h2 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h2><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>-XX:PretenureSizeThreshold, 指定大于该设置值的对象直接在老年代分配</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>-XX:MaxTenuringThreshold, 对象晋升老年代的年龄阈值</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发生Minor GC前, 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</span><br><span class="line"></span><br><span class="line">	条件成立, 这一次Minor GC是安全的</span><br><span class="line"></span><br><span class="line">	条件不成立, 查看-XX:HandlePromotionFailure参数设置值是否允许担保失败</span><br><span class="line"></span><br><span class="line">		允许, 检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</span><br><span class="line"></span><br><span class="line">			成立, 尝试一次Minor GC, 此次Minor GC有风险</span><br><span class="line"></span><br><span class="line">			不成立, 进行Full GC</span><br><span class="line"></span><br><span class="line">		不允许, 可进行Full GC</span><br></pre></td></tr></table></figure>
<p>JDK 6 Update 24之后-XX:HandlePromotionFailure不再使用, 规则变为只要老年代连续空间大于新生代对象总大小或历次晋升的平均大小, 就会进行Minor GC, 否则进行Full GC</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/17/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">第2章-Java内存区域与内存溢出异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 00:45:33" itemprop="dateCreated datePublished" datetime="2020-09-17T00:45:33+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-01 00:34:29" itemprop="dateModified" datetime="2021-03-01T00:34:29+08:00">2021-03-01</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200917004816840.png" alt="image-20200917004816840"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>线程私有, 一块较小的区域, 可以看作当前线程所执行的字节码的行号指示器.</p>
<p>如果是一个Java方法, 则记录正在执行的虚拟机字节码指令的地址</p>
<p>如果是Native方法, 则值为Undefined</p>
<p> 没有规定OutOfMemory Error情况的区域</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有, 每个方法执行时会创建一个栈帧Stack Frame, 用于存储局部变量、操作数栈、动态连接、方法出口等信息.</p>
<p>局部变量表存储了基本数据类型 (boolean、byte、short、int、float、long、double)、对象引用 (对象的引用指针)、returnAddress (字节码指令的地址)</p>
<p>这些类型在局部变量表中存储空间以槽slot表示, long和double占2个槽, 其他类型只占一个. 局部变量的空间也是按槽分配, 每个槽的大小由虚拟机决定 (可能为32、64比特或更多)</p>
<p>异常情况:</p>
<ul>
<li>StackOverflow Error: 线程申请的栈深度超限</li>
<li>OutOfMemory Error: 虚拟机无法申请足够栈空间.<ul>
<li>ps: HotSpot虚拟机的栈不能动态扩展</li>
</ul>
</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Native Method stacks, 与虚拟机栈的作用相似, 但为Native方法提供.</p>
<p>本地方法可以使用任意语言、使用方式和数据结构由虚拟机决定</p>
<p>Hotspot将本地方法栈和虚拟机栈合二为一</p>
<p>异常情况: StackOverflow Error和OutOfMemory Error</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>虚拟机启动时创建, 所有线程共享</p>
<p>存放对象实例和数组</p>
<p>垃圾收集器管理的内存区域, GC堆</p>
<p>堆可以实现为可扩展的或固定大小的, 主流的虚拟机都是可扩展的</p>
<p>异常: OutOfMemory Error</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>Method Area, 类似于Java堆, 线程共享</p>
<p>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译以后的代码缓存等数据</p>
<p>设计: 永久代 -&gt; 本地内存Native Memory</p>
<p>异常: OutOfMemory Error</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>Runtime Constant Pool, 方法区的一部分</p>
<p>用于存放编译期生成的Class文件中的各种字面量与符号引用</p>
<p>Java语言运行期间也可以将新的常量放入常量池中, 比如String::intern()</p>
<p>异常: OutOfMemory Error</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>Direct Memory</p>
<p>JDK1.4中加入了NIO (New Input/Output) 类, 引入了一种基于通道Channel与缓冲区Buffer的IO方式, 可直接使用Native函数库分配堆外内存, 然后通过Java堆的DirectByteBuffer对象引用这块区域.</p>
<p>不受Java堆大小限制, 但受本机总内存的限制</p>
<p>异常: OutOfMemory Error</p>
<h1 id="Hotspot虚拟机对象探秘"><a href="#Hotspot虚拟机对象探秘" class="headerlink" title="Hotspot虚拟机对象探秘"></a>Hotspot虚拟机对象探秘</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>这里的对象不包括数组和Class对象</p>
<ol>
<li>new指令创建对象</li>
<li>检查是否能在常量池中定位一个类的符号引用, 并检查符号引用代表的类是否已被加载、解析和初始化</li>
<li>为新对象在Java堆中分配内存 (所需空间在类加载完成时便可确定)</li>
<li>除对象头以外的区域初始化零值. 可能在TLAB分配阶段完成</li>
<li>对象头的设置, 元数据信息、对象hash值、GC分代年龄、是否启用偏向锁等信息</li>
<li>执行构造函数 (由编译器在new指令后自动插入字节码指令)</li>
</ol>
<p>Java堆内存的分配方式:</p>
<ul>
<li>指针碰撞Bump The Pointer: 空闲区和非空闲区通过指针作为分界点. CAS保证线程安全</li>
<li>空闲列表Free List: 空闲区和非空闲区交织在一起, 通过列表记录</li>
</ul>
<p>本地线程分配缓冲 Thread Local Allocation Buffler (TLAB): 预先为线程分配一块区域, 线程的内存分配先从TLAB中分配, 减少线程竞争</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象头Header:</p>
<ul>
<li>运行时数据, Mark word, 存储对象自身的运行时数据 (哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间等)<ul>
<li>Mark word: 32位或64位, 2个标志位指示了mark word中存储的数据情况</li>
<li><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200919171229126.png" alt="image-20200919171229126"></li>
</ul>
</li>
<li>类型指针, 指向类型元数据的指针 (对象属于哪个类)</li>
</ul>
<p>实例数据Instance Data: </p>
<ul>
<li>父类+子类各种类型的字段内容</li>
<li>相同宽度的字段总是被分配到一起存放, 父类中定义的变量会出现在子类之前. 分配顺序longs/doubles、ints、shorts/chars、bytes/booleans、oops (ordinary object pointers)</li>
<li>+XX: CompactFields=true时, 子类中较窄的变量允许插入父类变量的空隙之中</li>
</ul>
<p>对齐填充Padding: </p>
<ul>
<li>HotSpot虚拟机要求对象起始地址必须是8字节的整数倍, 任何对象大小都是8字节的整数倍 (1倍或2倍)</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>通过栈上的reference数据来操作堆上的具体对象. 具体实现由虚拟机决定, 主流的有两种方式:</p>
<ul>
<li><p>句柄: gc移动对象时, reference不需要修改</p>
<p><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200919172317823.png" alt="image-20200919172317823"></p>
</li>
<li><p>直接指针: 访问速度快, HotSpot使用</p>
<p><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200919172351042.png" alt="image-20200919172351042"></p>
</li>
</ul>
<h1 id="实战-OutOfMemory-Error异常"><a href="#实战-OutOfMemory-Error异常" class="headerlink" title="实战: OutOfMemory Error异常"></a>实战: OutOfMemory Error异常</h1><p>除了程序计数器外, VM的其他几个运行时区域都有发生OOM的可能</p>
<p>VM args:</p>
<ul>
<li><p><strong>-Xms</strong> 堆内存的最小大小，默认为物理内存的1/64</p>
</li>
<li><p><strong>-Xmx</strong> 堆内存的最大大小，默认为物理内存的1/4</p>
</li>
<li><p><strong>-Xmn</strong> 堆内新生代的大小。通过这个值也可以得到老生代的大小：-Xmx减去-Xmn</p>
</li>
<li><p>-XX: +HeapDumpOnOutOf-MemoryError: 出现OOM时Dump出当前的内存堆</p>
<ul>
<li>该文件可以通过Eclipse Memory Analyzer分析</li>
</ul>
</li>
<li><p>-Xss 栈容量</p>
</li>
<li><p>-Xoss 本地方法栈: HotSpot不区分虚拟机栈和本地方法栈, 该参数无效. 栈容量 = 单个进程最大内存限制 (32位是2G) - 最大堆容量 - 最大方法区容量</p>
</li>
</ul>
<p>对于非动态扩展栈的虚拟机, OOM只会在线程申请栈的时候发生. 对于动态扩展的虚拟机, OOM会发生在线程执行过程中</p>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>是方法区的一部分</p>
<p>String::intern(): 如果此String对象的字符串<strong>首次</strong>出现, 则添加到字符串常量池并返回引用, 否则返回该String对象在常量池中的引用</p>
<p>JDK7以前常量池在永久代, 会报PermGen space OOM, JDK7及以上字符串常量池从永久代移到了Java堆中, 会报Java heap space OOM</p>
<p>VM args:</p>
<ul>
<li>-XX: PermSize和-XX: MaxPermSize限制永久代大小</li>
</ul>
<h4 id="方法区-1"><a href="#方法区-1" class="headerlink" title="方法区"></a>方法区</h4><p>存储类型的相关信息, 类名、访问修饰符、常量池、字段描述、方法描述等</p>
<p>JDK 8以前存储在永久代, JDK 8及以后存储在元空间</p>
<p>动态产生类</p>
<ul>
<li> Java SE API的GeneratedConstructorAccessor和动态代理等</li>
<li>CGLib直接操作字节码在运行时生成</li>
<li>JSP第一次运行时需要编译为Java类、基于OSGi的应用</li>
</ul>
<p>VM args: 元空间的防止过多创建动态类的防御防御措施</p>
<ul>
<li>-XX: MaxMetaspaceSize: 指定元空间最大值, 默认-1不指定</li>
<li>-XX: MetaspaceSize: 指定元空间的初始空间大小, 字节为单位. 达到就会进行垃圾收集进行类型卸载, 同时对该值进行修改, 如果释放了大量空间就降低该值, 如果释放了很少空间就提升该值</li>
<li>-XX: MinMetaspaceFreeRatio: 控制垃圾收集之后最小的元空间剩余容量百分比, 减少因为元空间不足导致的垃圾收集频率</li>
</ul>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>直接内存Direct Memory</p>
<p>测试Direct Memory的OOM可以通过Unsafe类的allocateMemory方法在直接内存中分配, 直接内存的OOM产生的Heap Dump文件很小不会有明显的异常</p>
<p>DirectByteBuffer会先计算是否能够分配, 如果不能分配则会在代码手动抛出</p>
<p>常见的间接使用直接内存场景是NIO</p>
<p>VM args:</p>
<ul>
<li>-XX: MaxDirectMemorySize: 直接内存的容量大小, 如果不指定则和Java堆-Xmx一致</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/05/Java-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/Java-Note/" class="post-title-link" itemprop="url">Java Note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-05 14:20:57" itemprop="dateCreated datePublished" datetime="2020-09-05T14:20:57+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-06 23:20:24" itemprop="dateModified" datetime="2020-09-06T23:20:24+08:00">2020-09-06</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Filter、Interceptor、Aop实现与区别"><a href="#Filter、Interceptor、Aop实现与区别" class="headerlink" title="Filter、Interceptor、Aop实现与区别"></a>Filter、Interceptor、Aop实现与区别</h1><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>基于函数回调</p>
<p>是 java web 里面的，肯定获取不到 spring 里面 Controller 的信息</p>
<p>应用场景: 过滤请求的特殊字符，防止 SQL 注入</p>
<h3 id="Interceptor、Aspect"><a href="#Interceptor、Aspect" class="headerlink" title="Interceptor、Aspect"></a>Interceptor、Aspect</h3><p>和Spring相关, 能获取到Controller的信息</p>
<ul>
<li><p>Interceptor</p>
<p>AOP的一种运用, 基于 Java 的反射机制</p>
<p>可以使用Spring的依赖注入进行一些业务操作</p>
<p>应用场景：登录检查，请求执行时间等</p>
</li>
</ul>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>过滤前 - 拦截前 - aspect 开始执行- controller逻辑处理 - - aspect 结束 - 拦截后 - 过滤后</p>
<p><img src="/2020/09/05/Java-Note/image-20200905142442832.png" alt="image-20200905142442832"></p>
<h1 id="spring-security"><a href="#spring-security" class="headerlink" title="spring security"></a>spring security</h1><p>Ref: <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7f913e0681fc">https://www.jianshu.com/p/7f913e0681fc</a></p>
<h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成未认证的AuthenticationToken                 </span><br><span class="line">       ↑（获取信息）           （根据AuthenticationToken分配provider）                                    </span><br><span class="line"> AuthenticationFilter   -&gt;     AuthenticationManager    -&gt;    AuthenticationProvider</span><br><span class="line">                                                                      ↓（认证）</span><br><span class="line">                                                              UserDetails（一般查询数据库获取）</span><br><span class="line">                                                                      ↓（通过）</span><br><span class="line">                                                             生成认证成功的AuthenticationToken</span><br><span class="line">                                                                      ↓（存放）</span><br><span class="line">                                                                SecurityContextHolder</span><br></pre></td></tr></table></figure>
<p>自定义流程:</p>
<ul>
<li>自定义AuthenticationFilter、AuthenticationToken、AuthenticationProvider</li>
<li>AuthenticationFilter中生成AuthenticationToken (未认证)并传给AuthenticationManager来验证</li>
<li>AuthenticationProvider通过调用userDetailsService将未认证的Token进行验证并附带Authorities</li>
<li>配置: 实例化filter和provider并添加到Spring security中</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Max"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Max</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dongrongyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dongrongyu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rongyu.dong@gmail.com" title="E-Mail → mailto:rongyu.dong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Max</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '3nDJCTt3PoQ9qeabywtgL5qQ-gzGzoHsz',
      appKey     : 'HMGLSYCgLRuL0Tst8VMocAfj',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
