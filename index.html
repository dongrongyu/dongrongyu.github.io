<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongrongyu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Max&#39;s BigHouse">
<meta property="og:url" content="https://dongrongyu.github.io/index.html">
<meta property="og:site_name" content="Max&#39;s BigHouse">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Max">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://dongrongyu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Max's BigHouse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Max's BigHouse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学有所依</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis涉及与实现 - 数据结构与对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-19 23:20:54" itemprop="dateCreated datePublished" datetime="2021-02-19T23:20:54+08:00">2021-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-20 23:32:07" itemprop="dateModified" datetime="2021-02-20T23:32:07+08:00">2021-02-20</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis底层数据结构:</p>
<ul>
<li>SDS: 简单动态字符串, simple dynamic string</li>
<li>链表</li>
<li>字典</li>
<li>跳跃表</li>
<li>整数集合</li>
<li>压缩列表</li>
</ul>
<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>simple dynamic string, 简单动态字符串</p>
<p><img src="/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220005705662.png" alt="image-20210220005705662"></p>
<p>sizeof(buf) = len + free + 1</p>
<h2 id="空间重分配"><a href="#空间重分配" class="headerlink" title="空间重分配"></a>空间重分配</h2><h3 id="空间预分配"><a href="#空间预分配" class="headerlink" title="空间预分配"></a>空间预分配</h3><p>SDS修改, 发生空间扩展</p>
<ul>
<li>扩展后 len &lt;  1MB: 预分配 free = len, sizeof(buf) = free + len + 1</li>
<li>扩展后 len &gt; 1MB: 预分配 free = 1MB, sizeof(buf) = len + free(1MB) + 1</li>
</ul>
<h3 id="惰性空间释放"><a href="#惰性空间释放" class="headerlink" title="惰性空间释放"></a>惰性空间释放</h3><p>SDS缩短时, 不立即释放空间.</p>
<p>SDS提供了相应的API, 在有需要时真正释放SDS</p>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><p>通过len记录长度而不是‘\0’</p>
<h2 id="相比C字符串的优点"><a href="#相比C字符串的优点" class="headerlink" title="相比C字符串的优点"></a>相比C字符串的优点</h2><ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h2><p>双向链表</p>
<h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><p><img src="/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220232954579.png" alt="image-20210220232954579"></p>
<h3 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h3><p><img src="/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1/image-20210220233103318.png" alt="image-20210220233103318"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/11/23/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-11-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/23/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-11-14/" class="post-title-link" itemprop="url">Redis设计与实现 Chapter 11-14</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-11-23 12:26:53 / 修改时间：13:13:05" itemprop="dateCreated datePublished" datetime="2020-11-23T12:26:53+08:00">2020-11-23</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h1><p>AOF通过保存所有修改数据库的<strong>写命令请求</strong>来记录服务器数据库状态</p>
<p>以Redis<strong>命令请求协议</strong>的格式保存</p>
<p>写命令 -&gt; AOF缓冲区 -&gt; 同步写入到AOF文件</p>
<p>appendfsync选项:</p>
<ul>
<li>always: 写入 + 同步</li>
<li>everysec: 写入 + 每秒同步</li>
<li>no: 仅写入不同步, 同步依赖操作系统</li>
</ul>
<p>服务器启动后载入数据优先通过AOF文件</p>
<p>AOF重写:</p>
<ul>
<li>重写后文件体积更小</li>
<li>通过读取数据库中的键值对实现, 并不是读原有AOF文件</li>
</ul>
<p>执行BGWRITEAOF命令:</p>
<ul>
<li>期间维护一个AOF重写缓冲区, 记录重写过程中服务器执行的写命令</li>
<li>重写执行完后, AOF重写缓冲区中的内容追加到新AOF文件末尾, 使新旧文件保存的数据库状态一致</li>
<li>用新AOF文件替换旧文件</li>
</ul>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>类型:</p>
<ul>
<li><p>文件事件:</p>
<ul>
<li>对socket的抽象, 套接字变为acceptable、writable、readable状态时, 相应文件事件就会产生</li>
<li>基于Reactor模式实现的网络通信程序</li>
<li>AE_READABLE和AE_WRITABLE事件</li>
</ul>
</li>
<li><p>时间事件:</p>
<ul>
<li>定时事件、周期性事件</li>
<li>一般情况下只执行serverCron函数一个时间事件 (但这个函数执行了很多内容)</li>
<li>事件loop中, 先处理文件事件, 后处理时间事件. 处理过程中不抢占</li>
</ul>
</li>
</ul>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>clients链表连接了多个客户端状态, 新增加的客户端添加到链表末尾</p>
<p>客户端关闭情况:</p>
<ul>
<li>网络连接关闭</li>
<li>发送了不合协议格式的命令请求</li>
<li>CLIENT KILL</li>
<li>空转事件超时</li>
<li>输出缓冲区大小超出限制</li>
</ul>
<p>伪客户端:</p>
<ul>
<li>处理Lua脚本的伪客户端: 初始化创建, 一直存在</li>
<li>载入AOF文件的伪客户端: 载入工作创建, 完成后关闭</li>
</ul>
<p>flags标识客户端的角色和状态</p>
<p>输入缓冲区记录命令请求, 大小不能超过1GB</p>
<p>命令参数和参数个数纪录在argv和argc</p>
<p>cmd指向RedisCommand, 记录命令实现函数</p>
<p>输出缓冲区:</p>
<ul>
<li>固定大小缓冲区, 16KB</li>
<li>可变大小缓冲区, StringObject链表, 不能超过限制值<ul>
<li>硬性限制: 超过则关闭连接</li>
<li>软性限制: 一定时间内一直超过则关闭</li>
</ul>
</li>
</ul>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>命令请求从发送到完成的步骤:</p>
<ol>
<li>客户端发请求给服务器</li>
<li>server读取命令, 解析命令参数</li>
<li>根据命令查找实现函数, 执行命令并得出命令回复</li>
<li>server将命令回复返回给客户端</li>
</ol>
<p>serverCron: 每100ms执行一次</p>
<ul>
<li>更新服务器状态信息</li>
<li>处理SIGTERM信号</li>
<li>管理客户端资源和数据库状态</li>
<li>检查并执行持久化操作</li>
<li>…</li>
</ul>
<p>服务器初始化步骤:</p>
<ul>
<li>初始化服务器状态</li>
<li>initServerConfig, 载入服务器配置, 创建命令表</li>
<li>initServer, 初始化服务器数据结构: server.clients客户端状态链表, server.db数据库数组, server.pubsub_channels频道订阅信息的字典, server.pubsub_patterns模式订阅信息的链表、server.lua用于执行Lua脚本的Lua环境, server.slowlog用于保存满查询日志的属性</li>
<li>还原数据库状态: AOF、RDB</li>
<li>执行事件循环: 文件事件 + 时间时间</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/11/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-8-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/09/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-8-10/" class="post-title-link" itemprop="url">Redis设计与实现 Chapter 8-10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-09 11:52:56" itemprop="dateCreated datePublished" datetime="2020-11-09T11:52:56+08:00">2020-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-23 12:27:09" itemprop="dateModified" datetime="2020-11-23T12:27:09+08:00">2020-11-23</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>五种对象类型, 美中至少有两种以上的编码方式, 优化在不同场景的使用效率</p>
<table>
<thead>
<tr>
<th>对象类型</th>
<th>编码方式</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>字符串对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>列表对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>哈希对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集合对象</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>有序集合对象</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>服务器在执行命令之前, 会检查给定键的<strong>值对象类型</strong>能否执行指定的命令</p>
<p>内存回收通过<strong>引用计数</strong>实现</p>
<p>Redis只共享整数类型的字符串对象, 初始化时设置, 默认为0~9999</p>
<p>redistObject中的<strong>lru属性</strong>用于记录最后一次被访问的时间, 这个时间可以用于计算空转时间</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>redisServer.db存储所有的数据库, redisServer.dbnum属性保存数据库数量</p>
<p>客户端SELECT命令修改数据库, 让它指向redistServer.db中的不同元素来切换数据库</p>
<p>数据库主要有两个字典构成:</p>
<ul>
<li>dict: 保存数据库的所有键值对</li>
<li>expires: 保存键的过期时间, 键只想dict中的某个键, 值是过期时间</li>
</ul>
<p>数据库健总是一个字符串对象, 值可以是字符串对象、哈希表对象、集合对象、列表对象、有序集合对象</p>
<p>Redist过期健删除策略: 惰性删除 + 定期删除</p>
<p>SAVE和BGSVAE命令产生的新RDB文件不会包含已过期的键</p>
<p>过期键被删除后, 会追加一条DEL命令到AOF文件末尾</p>
<p>主服务器删除一个过期键后, 会向所有 从服务器发送一条DEL命令</p>
<p>从服务器发现过期键也不会删除</p>
<p>当Redis对数据库进行修改后, 会根据配置向客户端发送数据库通知</p>
<h1 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h1><p>RDB用于存储和还原Redis服务器中所有键值对数据</p>
<p>保存数据库到RDB:</p>
<ul>
<li>SAVE指令, 阻塞服务器进程保存数据库</li>
<li>BGSAVE指令: 生成子进程保存数据库, 不会阻塞服务器. 期间<ul>
<li>SAVE命令被拒绝</li>
<li>BGSAVE命令被拒绝</li>
<li>不能和BGREWRITEAOF同时执行, BGREWRITEAOF会被延迟到BGSAVE结束后执行</li>
</ul>
</li>
</ul>
<p>save选项设置服务器自动保存的条件</p>
<ul>
<li>save 300 10</li>
</ul>
<p>RDB是一个经过压缩的二进制文件, 不同类型的键值对以不同的方式来保存</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/10/26/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-1-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/26/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Chapter-1-7/" class="post-title-link" itemprop="url">Redis设计与实现 Chapter 1-7</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-26 10:26:40 / 修改时间：13:14:05" itemprop="dateCreated datePublished" datetime="2020-10-26T10:26:40+08:00">2020-10-26</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><p>数据库健总是一个字符串对象</p>
<p>数据库值的五种类型:</p>
<ul>
<li>字符串对象 string object</li>
<li>列表对象 list object</li>
<li>哈希对象 hash object</li>
<li>集合对象 set object</li>
<li>有序集合对象 sorted set object</li>
</ul>
<table>
<thead>
<tr>
<th>应用</th>
<th>底层实现</th>
</tr>
</thead>
<tbody><tr>
<td>列表键</td>
<td>链表</td>
</tr>
<tr>
<td>哈希键, Redis数据库的底层实现, CRUD</td>
<td>字典</td>
</tr>
<tr>
<td>有序集合键</td>
<td>跳表</td>
</tr>
<tr>
<td>集合键 (只包含整数)</td>
<td>整数集合</td>
</tr>
<tr>
<td>列表键、哈希键</td>
<td>压缩列表</td>
</tr>
</tbody></table>
<h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><p>Redis使用简单动态字符串 simple dynamic string (SDS)作为默认字符串实现</p>
<p>优点:</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存充分配次数<ul>
<li>空间预分配<ul>
<li>分配后len&lt;1MB, free = len</li>
<li>len &gt;= 1MB, free = 1MB</li>
</ul>
</li>
<li>惰性空间释放</li>
</ul>
</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ul>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>list结构 + listNode结构</p>
<p>双端链表</p>
<p>无环链表: 表头节点的前置指针和表尾节点的后置指针都指向NULL</p>
<p>值可以为不同类型: void *</p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>每个字典带有两个hash表, ht[1]在rehash时使用</p>
<p>用于哈希键和数据库时, 采用MurmurHash2算法</p>
<p>链地址法解决冲突</p>
<p>rehash过程采用渐进式, 将rehash的操作负载平分到每次操作上</p>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>zskiplist + zskiplistNode</p>
<p>每个跳跃节点的层高时1~32之间的随机数</p>
<p>score (double类型)可重复, 但是obj (字符串对象)必须唯一</p>
<p>score相同时, 按obj字符串的字典序排序</p>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>有序、无重复</p>
<p>自动升级: 集合元素从后往前扩展并迁移到新地址</p>
<p>升级操作的优点: 更加灵活、节约内存</p>
<p>不支持降级操作</p>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>为节约内存而开发的顺序型数据结构</p>
<p>每个节点可以保存一个字节数组或整数值</p>
<p>增、删节点又可能引发连锁更新, 但这种操作通常更新的节点数量不多且发生概率不高</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/10/20/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/20/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">第4章-虚拟机性能监控、故障处理工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-10-20 22:26:55 / 修改时间：22:44:43" itemprop="dateCreated datePublished" datetime="2020-10-20T22:26:55+08:00">2020-10-20</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基础故障处理工具"><a href="#基础故障处理工具" class="headerlink" title="基础故障处理工具"></a>基础故障处理工具</h1><h1 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h1><p>四个工具: JConsole、JHSDB、VisualVM、JMC</p>
<p>JConsole: JDK 5</p>
<p>JHSDB: JDK 9, 之前可以通过sa-jdi.jar包引入</p>
<p>VisualVM: JDK 6 Update 7, 已经从JDK中剥离, 但仍可以免费下载、使用</p>
<p>Java Mission Control: JDK 7 Update 40开始随JDK发布, JDK 11转入OpenJDK管理, 需要结合HotSpot Java Flight Recorder (JFR, 收费), 所以是OracleJDK商业特性</p>
<h2 id="JHSDB"><a href="#JHSDB" class="headerlink" title="JHSDB"></a>JHSDB</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">第3章-垃圾收集器和内存分配策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 23:30:26" itemprop="dateCreated datePublished" datetime="2020-09-22T23:30:26+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-09 13:55:22" itemprop="dateModified" datetime="2021-02-09T13:55:22+08:00">2021-02-09</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>程序计数器、虚拟机栈、本地方法栈分配内存在编译期可知, 随着方法结束或线程结束内存被回收</p>
<p>Java堆和方法区的内存分配具有不确定性, 是内存分配与回收的主要讨论方面</p>
<h1 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死?"></a>对象已死?</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>Reference counting, 每个对象用一个计数器来判断对象的存活情况</p>
<p>需要许多额外工作保证该算法正确的工作, 譬如: 难以处理对象之间循环引用的问题</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过GC Roots中的根对象作为起始节点, 从这些节点开始建立对象的引用链. 如果对象没有一条路径到达GC Roots, 则这个对象是不可达的.</p>
<p>该算法被用于Java、C#、Lisp等语言的内存管理</p>
<p>GC Roots的对象:</p>
<ul>
<li><strong>虚拟机栈</strong> (栈帧中的本地变量表) 中引用的对象, 如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li><strong>方法区中类静态属性引用的对象</strong>, 如Java类的引用类型静态变量</li>
<li><strong>方法区中常量引用的对象</strong>, 如字符串常量池中的引用</li>
<li><strong>本地方法栈JNI (Native方法)引用的对象</strong></li>
<li><strong>Java虚拟机内部的引用</strong>, 如基本数据类型的Class对象, 一些常驻的异常对象, 比如NullPointerException、OutOfMemoryError等</li>
<li><strong>所有被同步锁 (Synchronized关键字) 持有的对象</strong></li>
<li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>根据垃圾收集器的不同, 还有其他对象“临时性”的加入. 如针对Java堆的某一块区域的垃圾收集需要考虑是否与其他区域关联 (记忆集)</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>强引用String Reference: 代码中存在的引用关系, 即Object obj = new Object(), 垃圾收集器永远不会收集强引用对象</p>
<p>软引用SoftReference: 系统要发生溢出异常前会将这些对象列进回收范围进行回收, 如果还没有足够空间才会抛出内存溢出异常. SoftReference来实现</p>
<p>弱引用WeakReference: 只能生存到下一次垃圾收集发生. WeakReference类来实现</p>
<p>虚引用: 不对对象生存时间构成影响, 只为了在对象被收集时得到一个系统通知. PhantomReference类来实现</p>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡?"></a>生存还是死亡?</h2><p>对象销毁的两次标记过程:</p>
<ol>
<li>可达性分析后发现没有与GC Roots相连接的引用链</li>
<li>如果没有覆盖finalize()方法或finalize()方法已经被调用过, 只会被<u>调用一次</u></li>
</ol>
<p>如果需要执行finalize()方法, 对象将被放入F-Queue的队列中, 之后由虚拟机自动建立的、<strong>低调度优先级</strong>的Finalizer线程去执行. 虚拟机会触发刚方法的运行, 但不一定会等待它运行结束(防止长时间等待).</p>
<p>finalize()中若重新和引用链进行关联, 则可以不被回收 (只可逃脱一次), 如:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200924102412342.png" alt="image-20200924102412342"></p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区(HotSpot虚拟机中的元空间或者永久代)的回收比较严苛, 《Java虚拟机规范》并不要求方法区必须实现垃圾回收</p>
<p>主要回收: 废弃的常量、不再使用的类型</p>
<p>废弃常量的条件: 如字符串“java”进入常量池但没有任何对象引用该常量, 虚拟机也没有引用</p>
<p>不再使用的类条件: </p>
<ul>
<li>该类的所有实例或其派生子类的实例都已被回收</li>
<li>加载该类的类加载器已经被回收 (通常很难达成, 除非是经过精心设计的可替换类加载器的场景如OSGi、JSP的重加载等)</li>
<li>该类对应的java.lang.Class对象没有再任何地方被引用 (无法在任何地方通过反射访问该类的方法)</li>
</ul>
<p>大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景中, 需要JVM具备类型卸载能力, 以免对方法区造成过大内存压力</p>
<p>VM args:</p>
<ul>
<li>-Xnoclassgc: 控制虚拟机是否对类型进行回收</li>
<li>-verbose:class、-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息 (-XX:+TraceClassUnLoading需要FastDebug版虚拟机)</li>
</ul>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>两种方法: 引用计数式垃圾收集Reference Counting GC、追踪式垃圾收集Tracing GC, 也被称为直接式垃圾收集和间接式垃圾收集</p>
<p>本节内容均属于追踪式</p>
<h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>基于两个假说+一个用于解决跨代引用问题的经验法则:</p>
<ul>
<li>弱分代假说Weak Generatioal Hypothesis: 绝大多数对象都是朝生夕灭的</li>
<li>强分代假说Strong Generation Hypothesis: 熬过越多次垃圾收集过程的对象越难以消亡</li>
<li>跨带引用假说Intergenerational Reference Hypothesis: 跨带引用相对于同代引用来说仅占极少数</li>
</ul>
<p>新生代Young Generation: 每次收集会有大批对象死去, 每次回收后存活的少量对象, 将会逐步晋升到老年代中存放</p>
<p>老年代Old Generation: </p>
<p>依据跨带引用假说, 为了解决跨代引用问题, 需要在新生代上建立一个全局的数据结构记忆集Remembered Set</p>
<ul>
<li>该结构把老年代划分成若干小块, 标识出老年代哪一块内存会存在跨代引用, 此后Minor GC时需要将这些对象加入GC Roots</li>
<li>在对象改变引用关系时需要维护数据正确性</li>
</ul>
<p>一些GC名词:</p>
<ul>
<li>部分收集Partial GC, 目标不是收集整个Java堆的GC<ul>
<li>新生代收集Minor GC/Young GC</li>
<li>老年代收集Major GC/Old GC: 目前只有CMS收集器存在Old GC</li>
<li>混合收集Mixed GC: 目标是收集整个新生代和部分老年代的GC, 只有G1收集器有这种行为</li>
</ul>
</li>
<li>整堆收集Full GC: 收集整个Java堆和方法区</li>
</ul>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>Mark-Sweep算法, 包括标记+清除两个阶段</p>
<p>可以标记需要GC的对象也可以标记存活的对象, 然后执行清除需要GC的对象</p>
<p>缺点:</p>
<ul>
<li>执行效率不稳定. 如果Java堆中包含大量对象, 且大部分需要被回收, 这时标记和清除两个过程的执行效率随对象数量的增长大大降低</li>
<li>内存碎片化</li>
</ul>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>解决标记-清除算法存在的问题</p>
<p>将内存区域划分为相等的两块, GC时将存活的对象复制到另一块半区, 同时清理之前用的半区</p>
<p>改算法被主流的商用Java虚拟机新生代GC采用</p>
<p>Appel式回收 (Andrew Appel 1989年提出) 的Hotspot实现:</p>
<ul>
<li>一个Eden区+两个Survivor区</li>
<li>Eden和Survivor空间大小比例8:1</li>
<li>每次GC时将Eden区和Survivor区中存活的对象复制到另一块Survivor区中</li>
<li>每次新生代可用内存空间为容量的90%</li>
<li>分配担保Handle Promotion: 当Survivor空间不足以容纳一次Minor GC的存活对象时, 这些对象将直接进入老年代</li>
</ul>
<p>缺点:</p>
<ul>
<li>对象存活率高时需要较多复制操作, 不适用于老年代</li>
</ul>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>Mark-Compact算法, 类似标记-清除算法, 但是会将存活对象整理存放到一起解决内存碎片问题.</p>
<p>相比Mark-Sweep算法的优缺:</p>
<ul>
<li>GC时间长, 包括内存的复制过程</li>
<li>没有内存碎片问题</li>
<li>Mark-Sweep算法在内存碎片导致无法分配大对象时可能采取“分区空闲分配链表” 解决内存分配问题 (类似于磁盘存储大文件), 会是的分配和访问效率低. Mark-Compact则没这个问题</li>
</ul>
<p>一些垃圾收集器可能会结合使用Mark-Sweep和Mark-Compact</p>
<h1 id="HotSpot算法细节实现"><a href="#HotSpot算法细节实现" class="headerlink" title="HotSpot算法细节实现"></a>HotSpot算法细节实现</h1><h2 id="根结点枚举"><a href="#根结点枚举" class="headerlink" title="根结点枚举"></a>根结点枚举</h2><p>GC Roots节点主要为全局性引用 (常量或类静态属性)与执行上下文(栈帧的本地变量表)</p>
<p>根结点枚举的过程必须暂停用户线程</p>
<p>虚拟机其实并不需要一个不漏的从方法区等GC Roots获取哪些地方存放着对象引用的, 虚拟机是可以直接得到哪些地方存放着对象引用的. HotSpot通过OopMap (Ordinary Object Pointer)记录, 在类加载动作完成, 会把对象什么偏移量上是什么类型的数据计算出来, 即使是即使编译, 也会在某个位置记录下栈里和寄存器哪些位置是引用.</p>
<p>???不太懂</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928195908139.png" alt="image-20200928195908139"></p>
<p>OopMap是针对指令的数据结构, 会为某条特定位置的指令生成</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>Safepoint, 用于生成OopMap的特定位置, 也是发生GC的指令位置, 避免对每条指令生成造成过多存储空间浪费. 设立不能太短也不能太长</p>
<p>安全点的选取以“是否具有让程序长时间执行的特征”为标准, 例如方法调用、循环跳转、异常跳转等指令序列复用的位置</p>
<p>让所有线程(其实不包括JNI调用的线程)跑到安全点停下的方式:</p>
<ul>
<li>抢先式中断Preemptive Suspension, 现有虚拟机一般不采用<ul>
<li>垃圾收集式, 系统让用户线程全部中断, 如果发现有用户线程不在安全点上则恢复其执行过一会再中断, 直到跑到安全点</li>
</ul>
</li>
<li>主动式中断Voluntary Suspension<ul>
<li>设一个标志位, 各个线程执行过程中不断轮训, 一旦发现标志位true则再最近安全点上主动挂起</li>
<li>轮询位置: 安全点 + 所有创建对象和其他需要再Java堆上分配内存的地方</li>
<li>HotSpot使用内存保护陷阱方式实现<ul>
<li>一条汇编指令</li>
<li>预先注册异常处理器, 需要用户线程暂停时置0x160100内存页为不可读, test指令则发生自陷异常信号, 线程挂起等待</li>
<li><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928234101400.png" alt="image-20200928234101400"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>Safe Region, 引用关系不会发生变化的代码片段, 虚拟机可以不需要等待在安全区域中的线程</p>
<p>用于避免线程处于Sleep状态或Blocked状态的情况</p>
<p>线程离开安全区域时, 需要检查虚拟机是否完成了根节点枚举(或暂停其他用户线程的阶段), 如果还未完成则需等待信号, 否则直接继续执行.</p>
<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><p>记忆集Remembered Set: 用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
<p>记录精度:</p>
<ul>
<li>非收集区域的所有跨代引用对象数组, 空间占用和维护成本高<ul>
<li><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120232896.png" alt="image-20200929120232896"></li>
</ul>
</li>
<li>字长精度: 精确到一个机器字长, 记录该字包含跨代指针</li>
<li>对象精度: 精确到一个对象, 该对象有跨代指针的字段</li>
<li>卡精度: 一块内存区域, 改区域内有对象含有跨代指针</li>
</ul>
<p>卡精度为最常用的记忆集实现方式, 通过卡表Card Table方式实现记忆集.</p>
<p>卡表: </p>
<ul>
<li><p>字节数组</p>
<ul>
<li>CARD_TABLE [this address &gt;&gt; 9] = 0;</li>
</ul>
</li>
<li><p>如果卡页中有对象存在跨代引用, 则标识为1</p>
</li>
<li><p>每个元素都对应标识内存区域一块特定大小的内存块(卡页), 如上代表2^9=512字节</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120706248.png" alt="image-20200929120706248"></p>
</li>
</ul>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>写屏障Write Barrier: 维护卡表状态的技术, 可以看作虚拟机层面对“引用类型字段赋值”的AOP操作, 这个操作会被编译器放到每一个赋值操作之中.</p>
<p>对引用对象赋值产生一个Around通知, 执行额外动作. 又分为写前屏障Pre-Write Barrier和写后屏障Post-Write Barrier. 除了G1收集器, 其他收集器都只用到了写后屏障</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929154351247.png" alt="image-20200929154351247"></p>
<p>写屏障会带来赋值时的额外开销, 不过相比Minor GC扫描整个老年代要低得多</p>
<p>伪共享问题False Sharing: 多个线程对属于同一Cache line的卡表元素操作时由于缓存一致性同步导致的性能降低</p>
<p>伪共享问题可通过修改前判断来降低影响</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929155628297.png" alt="image-20200929155628297"></p>
<p>VM args:</p>
<ul>
<li>-XX:+UseCondCardMark: 用来决定是否开启卡表更新的条件判断</li>
</ul>
<h2 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h2><p>用户线程和收集器并发工作带来的问题:</p>
<ul>
<li>原本消亡的对象标记为存活. 可以容忍</li>
<li>原本存活的对象标记为消亡 (对象消失). 不可产生</li>
</ul>
<p>三色标记:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929160844578.png" alt="image-20200929160844578"></p>
<p>“对象消失” 的条件 (1994, Wilson):</p>
<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ol>
<p>“对象消失”的解决方案:</p>
<ul>
<li>增量更新(Incremental Update): 破坏条件一, 黑色对象插入白色对象引用时, 将这个新插入的引用记录下来, 收集结束后, 再将这些引用关系中的黑色对象标记为灰色, 重新扫描一次</li>
<li>原始快照(Snapshot At The Beginning): 破坏条件二, 灰色对象要删除指向白色对象的引用关系时, 记录这个删除的引用, 在扫描结束时, 将这些对象标记为灰色, 重新扫描. 其实就是按刚开始扫描的引用结构搜索</li>
</ul>
<p>增量更新: CMS</p>
<p>原始快照: G1、Shenandoah</p>
<h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><p>“经典” : &gt;=JDK 7 Update 4, &lt;JDK11</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929162601589.png" alt="image-20200929162601589"></p>
<p>JDK 9时图中两种收集器组合被废弃</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>最基础的、历史悠久的收集器. 仍是HotSpot虚拟机运行在客户端模式下的默认新生代收集器</p>
<p>单线程收集器, 工作时必须暂停其他所有工作线程</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929164608367.png" alt="image-20200929164608367"></p>
<p>优缺:</p>
<ul>
<li>简单而高效</li>
<li>额外内存消耗少</li>
<li>单核处理器或核心数少的环境来说, 比较高效</li>
<li>适用于桌面应用场景和部分微服务应用</li>
</ul>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器的多线程并行版本, 除了GC时候使用多线程, 其余都和Serial相同</p>
<p>新生代收集器</p>
<p>ParNew + Serial Old:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929165537962.png" alt="image-20200929165537962"></p>
<p>主要在JDK 5中用于和CMS搭配使用</p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>新生代收集器, 使用标记-复制算法, 和ParNew类似</p>
<p>Parallel Scavenge收集器主要关注吞吐量, 又称为吞吐量收集器, 目的在于控制垃圾收集时间占程序总执行时间的比例.</p>
<p>自适应调节策略(GC Ergonomics)来动态调整Java堆上各个分代空间的分配</p>
<p>VM args:</p>
<ul>
<li>-XX:MaxGCPauseMills: 一次GC允许的最长时间的ms.</li>
<li>-XX:GCTimeRatio: 允许的最大垃圾收集时间比例, 设定为x时, 最大垃圾收集时间占总时间的1/(1+x)</li>
<li>-XX:+UseAdaptiveSizePolicy: 自适应调节策略, 启用后不再需要指定新生代大小(-Xmn)、Eden与Survivor的比例(-XX:SurvivorRatio)、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数, Parallel Scavenge收集器会根据运行时监控信息动态调整以提供<u>最合适的停顿时间</u>和<u>最大的吞吐</u></li>
</ul>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial的老年代版本, 单线程收集器, 使用标记-整理算法</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929173655549.png" alt="image-20200929173655549"></p>
<p>使用场景:</p>
<ul>
<li>客户端模式的HotSpot虚拟机使用</li>
<li>&lt;=JDK 5时搭配Parallel Scavenge收集器使用</li>
<li>CMS发生Concurrent Mode Failure时使用</li>
</ul>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>JDK 6提供, Parallel Scavenge收集器的老年代版本, 并发收集, 使用标记-整理算法</p>
<p>主要用于和Parallel Scavenge的搭配使用</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929174133829.png" alt="image-20200929174133829"></p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS (Concurrent Mark Sweep)以获取最短回收停顿时间为目标的收集器, 使用标记-清除算法. 总体上来说为并发收集器</p>
<p>执行步骤:</p>
<ol>
<li>初始标记 (CMS initial mark)</li>
<li>并发标记 (CMS cocurrent mark)</li>
<li>重新标记 (CMS remark)</li>
<li>并发清除 (CMS concurrent sweep)</li>
</ol>
<p>其中1、3需要停顿用户线程, 通常3执行时间大于1, 2、4耗时时间最长</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929175220239.png" alt="image-20200929175220239"></p>
<p>三个明显缺点:</p>
<ul>
<li>处理器资源敏感: 默认回收线程数为(处理器核心数+3)/4, 核心数&gt;4时, 占用约为25%的处理器运算资源, &lt;4时影响较大. 增量式并发收集器i-CMS使得用户线程可以和垃圾收集线程在一个核心交替执行缓解该问题, 但效果不好在JDK 9废弃</li>
<li>无法处理“浮动垃圾” (FLoating Garbage), 出现“Concurrent Mode Failure”: 由于2、4阶段用户线程在运行可能产生垃圾, 如果预留的内存空间无法满足分配新对象的需求, 会出现“Concurrent Mode Failure”, 此时会启用Serial Old收集器执行一次暂停用户线程执行GC.</li>
<li>内存碎片: Mark-Sweep算法导致, 无法分配时会导致Full GC. Full GC需要完全停止用户线程执行. 可以通过两个参数调节</li>
</ul>
<p>VM args:</p>
<ul>
<li>-XX:CMSInitiatingOccupancyFraction: 执行CMS时老年代的使用空间比例</li>
<li>-XX:+UseCMSCopmpactAtFullCollection: 在FUll GC时进行内存整理, JDK 9废弃</li>
<li>-XX:CMSFullGCsBeforeCompation: 执行若干次不整理空间的Full GC后, 下一次进入Full GC前会先进行碎片整理, 默认为0. JDK 9废弃</li>
</ul>
<h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>G1收集器, JDK 7提出. JDK 9替代Parallel Scavenge+Parallel Old组合成为默认收集器, CMS成为Deprecate, 但由于历史遗留, 规划在JDK 10提出“统一垃圾收集器接口”.</p>
<p>基于Region的堆内存布局:</p>
<ul>
<li>连续的Java堆被划分成多个大小相等的独立区域Region, 每个Region都可以根据需要扮演新生代的Eden空间、Survivor空间或者老年代空间</li>
<li>Humongous区域: <ul>
<li>专门用来存储大对象, G1大多数行为都把Humongous Region作为老年代的一部分来看待.</li>
<li>只要大小超过一个Region容量的一半则可视为大对象</li>
<li>超过整个Region容量的超级大对象, 会放在N个连续的Humongous Region之中</li>
<li>-XX:G1HeapRegionSize: 1MB~32MB, 每个region的大小</li>
</ul>
</li>
</ul>
<p>G1收集器对内存任何部分组成的回收集Collection Set (CSet) 来进行回收, 不再针对分代, 而是哪块内存的垃圾数量多, 回收收益最大</p>
<p>G1对扮演不同角色的Region采用不同的策略去处理</p>
<p>G1是一个“<strong>停顿时间模型</strong>”的收集器</p>
<ul>
<li>建立起可预测的停顿时间模型是因为以Region为单次回收的最小单元</li>
<li>每次收集的内存空间都是Region大小的整数倍</li>
<li>避免在整个Java堆中进行全区域垃圾收集</li>
<li>依赖垃圾堆积的“价值”大小建立<strong>优先级列表</strong>, 在允许的停顿时间 (-XX:MaxGCPauseMillis) 内优先处理收益最大的Region</li>
<li>“价值”: 回收所获的的空间大小以及回收所需时间的经验值</li>
</ul>
<p>G1设计的细节问题:</p>
<ul>
<li>跨Region的引用对象如何解决: <ul>
<li>每个region维护自己的记忆集, 这些记忆集记录别的region指向自己的卡页范围.</li>
<li>记忆集的实现通过一个哈希表, Key是别的Region的起始地址, Value是一个集合, 里面存储的元素是卡表的索引号.</li>
<li>Region数量比传统分代数量多的多, G1至少要耗费Java堆容量的10%~20%额外内存来维持收集器工作</li>
</ul>
</li>
<li>收集线程如何与用户线程并发执行:<ul>
<li>G1通过原始快照SATB算法来实现</li>
<li>每个Region有两个TAMS (Top at Mark Start) 指针, 新分配对象地址必须在这两个指针位置以上, 即它们是默认存活不纳入回收范围</li>
<li>如果回收速度赶不上分配速度, 也会导致Full m GC冻结用户线程执行</li>
</ul>
</li>
<li>怎样建立可靠的停顿预测模型:<ul>
<li>-XX:MaxGCPauseMillis: 指定停顿时间</li>
<li>G1会统计每个Region的回收耗时、每个Region记忆集里脏卡数量等各个可测量步骤花费的成本, 分析得出衰减平均值 (更准确代表“最近”的平均状态)、标准偏差、置信度等统计信息, 通过这些信息预测现在开始回收哪些Region组成的回收集可以在不超过期望停顿时间内获得最高的收益</li>
</ul>
</li>
</ul>
<p>G1收集器的四个步骤:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930004721338.png" alt="image-20200930004721338"></p>
<p>只有在并发标记阶段是并发的, G1的主要目标时间延迟可控的情况下获得尽可能高的吞吐, “全功能收集器”</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930005222909.png" alt="image-20200930005222909"></p>
<p>停顿时间设置的过小会使得回收赶不上内存分配导致Full GC</p>
<p>G1设计上更注重能够应付内存分配速率 (Allocation Rate) 而不追求一次把Java堆全部清理干净</p>
<p>G1和CMS对比:</p>
<ul>
<li>G1可以指定对打停顿时间、分Region内存布局、通过“价值”确定回收集</li>
<li>G1收集不会产生内存碎片, CMS会因内存碎片导致Full GC</li>
<li>G1内存占用和执行负载高</li>
<li>G1每个Region都需要一个卡表, CMS只有新生代有一个卡表. 都通过写后屏障维护</li>
<li>G1使用原始快照搜索SATB算法, 写前屏障来实现指针引用的变化, 避免最终标记阶段时间过长. CMS通过增量算法. 增量算法为什么不需要写前屏障呢???</li>
<li>G1写屏障操作复杂, 放入队列进行异步处理. CMS写屏障同步处理</li>
</ul>
<p>通常CMS在小内存上表现会优于G1, 大内存上G1性能更好</p>
<h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><p>Red hat写的收集器, Oracle G1收集器的继承者, 只在OpenJDK中包含, 被OracalJDK通过条件编译排除</p>
<p>为程序执行提供低延迟的GC停顿时间, 高运行负担情况下吞吐量低于G1、CMS和Parallel Scavenge. 据表3-2的测试结果</p>
<p>相比G1:</p>
<ul>
<li>基于Region的对内存管理</li>
<li>支持并发的整理算法</li>
<li>不使用分代收集 (并不是说分代收集对Shenandoah没有价值)</li>
<li>使用连接矩阵(Connection Matrix), 而不是用G1的记忆集实现方式</li>
</ul>
<p>连接矩阵Connection Matrix: 降低了记忆集维护消耗, 也降低了伪共享问题</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019153724892.png" alt="image-20201019153724892"></p>
<p>步骤:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160542645.png" alt="image-20201019160542645"></p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160603709.png" alt="image-20201019160603709"></p>
<p><strong>三个重要阶段</strong>: 并发标记、并发回收、并发引用更新</p>
<p>工作流程:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019161007965.png" alt="image-20201019161007965"></p>
<h3 id="Brooks-Pointer"><a href="#Brooks-Pointer" class="headerlink" title="Brooks Pointer"></a>Brooks Pointer</h3><p>原始的转发指针操作实现:</p>
<ul>
<li>步骤:<ol>
<li>在被移动对象的原有内存上设置Memory Protection Trap</li>
<li>访问旧对象时的内存空间时产生自陷中断, 调用异常处理器</li>
<li>将代码访问转发到复制后的新对象上</li>
</ol>
</li>
<li>缺点: 如果没有操作系统支持, 这种方案导致用户态频繁切换到核心态, 代价高</li>
</ul>
<p>Brooks Pointer (Forward Pointer):</p>
<ul>
<li><p>方案: </p>
<ul>
<li>在对象头部增加Brooks Pointer</li>
<li>没有Memory Protection Trap的问题, 但是对像访问多了一次间接跳转</li>
</ul>
</li>
<li><p>对象未被移动时:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019162035357.png" alt="image-20201019162035357"></p>
</li>
<li><p>被移动后:</p>
</li>
</ul>
<p>并发写Brooks Pointer:</p>
<ul>
<li><p>问题:</p>
<ol>
<li><p>收集器线程复制了对象</p>
</li>
<li><p>用户线程更新对象某个字段     –&gt; 写在旧对象上</p>
</li>
<li><p>收集器线程更新转发指针的引用为新副本地址</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019170904557.png" alt="image-20201019170904557"></p>
</li>
</ol>
</li>
<li><p>解决方式: Shenandoah收集器通过CAS保证并发对象访问的正确性</p>
</li>
</ul>
<p>为了实现Brooks Pointer, Shenandoah在读、写屏障中都加入了额外的转发处理</p>
<p>基于引用访问屏障 Load reference Barrier:</p>
<ul>
<li>为了减少读屏障对访问带来的问题, 计划在JDK 13中引入</li>
<li>只拦截对象中数据类型为引用类型的读写操作, 而不去管原声数据类型等其他非引用字段的读写</li>
</ul>
<h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>PGC和G4收集器的继承者</p>
<p>ZGC特征:</p>
<ul>
<li>基于Region内存布局</li>
<li>(暂时)不设分代</li>
<li>使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法</li>
<li>以低延迟为首要目标</li>
</ul>
<p>ZGC的Region (Page、ZPage): 具有动态性 (动态创建和销毁、动态容量大小)</p>
<ul>
<li>Small Region: 2MB, 放置&lt;256KB的小对象</li>
<li>Medium Region: 32MB, 放置&gt;=256KB但&lt;4MB的对象</li>
<li>Large Region: 容量动态变化, 为2MB的整数倍. 放置4MB及以上的<u>一个</u>大对象 (所以large region可能小雨medium region). 由于拷贝开销大, Large region在ZGC中不会被重分配</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019182007284.png" alt="image-20201019182007284"></p>
<h3 id="染色指针-Colored-Pointer、Tag-Pointer、Version-Pointer"><a href="#染色指针-Colored-Pointer、Tag-Pointer、Version-Pointer" class="headerlink" title="染色指针 (Colored Pointer、Tag Pointer、Version Pointer)"></a>染色指针 (Colored Pointer、Tag Pointer、Version Pointer)</h3><p>在对象引用上记录信息的一项技术</p>
<p>64位系统 -&gt; AMD架构只支持48位虚地址空间 -&gt; 64位Linux支持47位需地址空间和46位物理地址空间</p>
<p>46位地址空间仍然过剩, 所以取高4位来存储四个标志信息:</p>
<ul>
<li>对象三色标记状态</li>
<li>是否进入了重分配集 (即被移动过)</li>
<li>是否只能通过finalize()方法才能访问到</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019183401317.png" alt="image-20201019183401317"></p>
<p>缺点:</p>
<ul>
<li>4TB的内存限制</li>
<li>不能支持32位平台</li>
<li>不能支持压缩指针(-XX:+UseCompressedOops)</li>
<li>……</li>
</ul>
<p>优势:</p>
<ul>
<li>Region存活对象被移走之后, 这个Region能立即释放, 而不用等到整个堆中所有指向该Region的引用都被修正</li>
<li>大幅减少读、写屏障的使用量. 使用内存屏障目的时记录对象引用变化情况, 但这些信息直接维护在指针中了. ZGC只使用了读屏障 (原因是染色指针和不支持分代) </li>
<li>可以作为一种扩展结构记录更多与对象标记、重定位过程相关的数据, 用以提高性能. 譬如记录低频访问对象, 转移到不常访问的内存区域</li>
</ul>
<p>多重映射 (Multi-Mapping):</p>
<ul>
<li>LInux/x86-64平台上ZGS使用多重映射将不同的虚拟地址映射到同一物理地址上</li>
<li>多重映射技术是怎么实现的呢???</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019195358982.png" alt="image-20201019195358982"></p>
<h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005314958.png" alt="image-20201020005314958"></p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005346874.png" alt="image-20201020005346874"></p>
<p>理解: </p>
<ul>
<li>并发标记阶段的GC Roots应该不包括跨region的指针. 在并发预备重分配中会扫描其他所有region来定位跨region指针指向重分配集中的对象.</li>
<li>重分配的时候应该对对象的所有引用指针进行染色, 这个过程应该是原子操作的, 应该也会造成停顿时间???</li>
</ul>
<h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><p>没有使用记忆集、分代, 因此不需要写屏障, 但GC时间长, 能承受的对象分配速率不会太高 (解决该问题的根本方法是分代收集, 针对新生代进行更频繁、更快的收集)</p>
<p>NUMA-aware的内存分配. 在ZGA之前只有Parallel Scavenge支持NUMA-aware内存分配</p>
<p>GC过程低延迟, 吞吐量也比较高能达到Parallel Scavenge的90% (根据图3-23结果)</p>
<h1 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h1><h2 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h2><p>JDK 10开始, 为了隔离垃圾收集器堉Java虚拟机解释、编译、监控等子系统的关系, RedHat提出了垃圾收集的统一接口, Epsilon是这个接口的有效性验证和参考实现</p>
<p>不干活的收集器</p>
<p>用于剥离垃圾收集器影响的性能测试和压力测试</p>
<p>用于不需要垃圾收集就会推出的极小应用</p>
<h2 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h2><h2 id="虚拟机及垃圾收集器日志"><a href="#虚拟机及垃圾收集器日志" class="headerlink" title="虚拟机及垃圾收集器日志"></a>虚拟机及垃圾收集器日志</h2><p>JDK 9之后所有日志都可以利用-Xlog参数统一输出格式</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220853939.png" alt="image-20201020220853939"></p>
<p>日志支持的所有模块:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220910121.png" alt="image-20201020220910121"></p>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><h1 id="实战-内存分配与回收策略"><a href="#实战-内存分配与回收策略" class="headerlink" title="实战: 内存分配与回收策略"></a>实战: 内存分配与回收策略</h1><p>概念上来讲, 对象应该都在堆上分配 (实际上可能经过即时编译后被拆散成标量类型并间接地在栈上分配)</p>
<h2 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h2><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>-XX:PretenureSizeThreshold, 指定大于该设置值的对象直接在老年代分配</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>-XX:MaxTenuringThreshold, 对象晋升老年代的年龄阈值</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>发生Minor GC前, 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</p>
<p>​    条件成立, 这一次Minor GC是安全的</p>
<p>​    条件不成立, 查看-XX:HandlePromotionFailure参数设置值是否允许担保失败</p>
<p>​        允许, 检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</p>
<p>​            成立, 尝试一次Minor GC, 此次Minor GC有风险</p>
<p>​            不成立, 进行Full GC</p>
<p>​        不允许, 可进行Full GC</p>
<p>JDK 6 Update 24之后-XX:HandlePromotionFailure不再使用, 规则变为只要老年代连续空间大于新生代对象总大小或历次晋升的平均大小, 就会进行Minor GC, 否则进行Full GC</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/17/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="post-title-link" itemprop="url">第2章-Java内存区域与内存溢出异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-17 00:45:33" itemprop="dateCreated datePublished" datetime="2020-09-17T00:45:33+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-20 22:27:43" itemprop="dateModified" datetime="2020-10-20T22:27:43+08:00">2020-10-20</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200917004816840.png" alt="image-20200917004816840"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>线程私有, 一块较小的区域, 可以看作当前县城所执行的字节码的行号指示器.</p>
<p>如果是一个Java方法, 则记录正在执行的虚拟机字节码指令的地址</p>
<p>如果是Native方法, 则值为Undefined</p>
<p> 没有规定OutOfMemory Error情况的区域</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有, 每个方法执行时会创建一个栈帧Stack Frame, 用于存储局部变量、操作数栈、动态连接、方法出口等信息.</p>
<p>局部变量表存储了基本数据类型 (boolean、byte、short、int、float、long、double)、对象引用 (对象的引用指针)、returnAddress (字节码指令的地址)</p>
<p>这些类型在局部变量表中存储空间以槽slot表示, long和double占2个槽, 其他类型只占一个. 局部变量的空间也是按槽分配, 每个槽的大小由虚拟机决定 (可能为32、64比特或更多)</p>
<p>异常情况:</p>
<ul>
<li>StackOverflow Error: 线程申请的栈深度超限</li>
<li>OutOfMemory Error: 虚拟机无法申请足够栈空间.<ul>
<li>ps: HotSpot虚拟机的栈不能动态扩展</li>
</ul>
</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>Native Method stacks, 与虚拟机栈的作用相似, 但为Native方法提供.</p>
<p>本地方法可以使用任意语言、使用方式和数据结构由虚拟机决定</p>
<p>Hotspot将本地方法栈和虚拟机栈合二为一</p>
<p>异常情况: StackOverflow Error和OutOfMemory Error</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>虚拟机启动时创建, 所有线程共享</p>
<p>存放对象实例和数组</p>
<p>垃圾收集器管理的内存区域, GC堆</p>
<p>堆可以实现为可扩展的或固定大小的, 主流的虚拟机都是可扩展的</p>
<p>异常: OutOfMemory Error</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>Method Area, 类似于Java堆, 线程共享</p>
<p>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译以后的代码缓存等数据</p>
<p>设计: 永久代 -&gt; 本地内存Native Memory</p>
<p>异常: OutOfMemory Error</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>Runtime Constant Pool, 方法区的一部分</p>
<p>用于存放编译期生成的Class文件中的各种字面量与符号引用</p>
<p>Java语言运行期间也可以将新的常量放入常量池中, 比如String::intern()</p>
<p>异常: OutOfMemory Error</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>Direct Memory</p>
<p>JDK1.4中加入了NIO (New Input/Output) 类, 引入了一种基于通道Channel与缓冲区Buffer的IO方式, 可直接使用Native函数库分配堆外内存, 然后通过Java堆的DirectByteBuffer对象引用这块区域.</p>
<p>不受Java堆大小限制, 但受本机总内存的限制</p>
<p>异常: OutOfMemory Error</p>
<h1 id="Hotspot虚拟机对象探秘"><a href="#Hotspot虚拟机对象探秘" class="headerlink" title="Hotspot虚拟机对象探秘"></a>Hotspot虚拟机对象探秘</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>这里的对象不包括数组和Class对象</p>
<ol>
<li>new指令创建对象</li>
<li>检查是否能在常量池中定位一个类的符号引用, 并检查符号引用代表的类是否已被加载、解析和初始化</li>
<li>为新对象在Java堆中分配内存 (所需空间在类加载完成时便可确定)</li>
<li>除对象头以外的区域初始化零值. 可能在TLAB分配阶段完成</li>
<li>对象头的设置, 元数据信息、对象hash值、GC分代年龄、是否启用偏向锁等信息</li>
<li>执行构造函数 (由编译器在new指令后自动插入字节码指令)</li>
</ol>
<p>Java堆内存的分配方式:</p>
<ul>
<li>指针碰撞Bump The Pointer: 空闲区和非空闲区通过指针作为分界点. CAS保证线程安全</li>
<li>空闲列表Free List: 空闲区和非空闲区交织在一起, 通过列表记录</li>
</ul>
<p>本地线程分配缓冲 Thread Local Allocation Buffler (TLAB): 预先为线程分配一块区域, 线程的内存分配先从TLAB中分配, 减少线程竞争</p>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象头Header:</p>
<ul>
<li>运行时数据, Mark word, 存储对象自身的运行时数据 (哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间等)<ul>
<li>Mark word: 32位或64位, 2个标志位指示了mark word中存储的数据情况</li>
<li><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200919171229126.png" alt="image-20200919171229126"></li>
</ul>
</li>
<li>类型指针, 指向类型元数据的指针</li>
</ul>
<p>实例数据Instance Data: </p>
<ul>
<li>父类+子类各种类型的字段内容</li>
<li>相同宽度的字段总是被分配到一起存放, 父类中定义的变量会出现在子类之前. 分配顺序longs/doubles、ints、shorts/chars、bytes/booleans、oops (ordinary object pointers)</li>
<li>+XX: CompactFields=true时, 子类中较窄的变量允许插入父类变量的空隙之中</li>
</ul>
<p>对齐填充Padding: </p>
<ul>
<li>HotSpot虚拟机要求对象起始地址必须是8字节的整数倍, 任何对象大小都是8字节的整数倍 (1倍或2倍)</li>
</ul>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>通过栈上的reference数据来操作堆上的具体对象. 具体实现由虚拟机决定, 主流的有两种方式:</p>
<ul>
<li><p>句柄: gc移动对象时, reference不需要修改</p>
<p><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200919172317823.png" alt="image-20200919172317823"></p>
</li>
<li><p>直接指针: 访问速度快, HotSpot使用</p>
<p><img src="/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/image-20200919172351042.png" alt="image-20200919172351042"></p>
</li>
</ul>
<h1 id="实战-OutOfMemory-Error异常"><a href="#实战-OutOfMemory-Error异常" class="headerlink" title="实战: OutOfMemory Error异常"></a>实战: OutOfMemory Error异常</h1><p>除了程序计数器外, VM的其他几个运行时区域都有发生OOM的可能</p>
<p>VM args:</p>
<ul>
<li><p><strong>-Xms</strong> 堆内存的最小大小，默认为物理内存的1/64</p>
</li>
<li><p><strong>-Xmx</strong> 堆内存的最大大小，默认为物理内存的1/4</p>
</li>
<li><p><strong>-Xmn</strong> 堆内新生代的大小。通过这个值也可以得到老生代的大小：-Xmx减去-Xmn</p>
</li>
<li><p>-XX: +HeapDumpOnOutOf-MemoryError: 出现OOM时Dump出当前的内存堆</p>
<ul>
<li>该文件可以通过Eclipse Memory Analyzer分析</li>
</ul>
</li>
<li><p>-Xss 栈容量</p>
</li>
<li><p>-Xoss 本地方法栈: HotSpot不区分虚拟机栈和本地方法栈, 该参数无效. 栈容量 = 单个进程最大内存限制 (32位是2G) - 最大堆容量 - 最大方法区容量</p>
</li>
</ul>
<p>对于非动态扩展栈的虚拟机, OOM只会在线程申请栈的时候发生. 对于动态扩展的虚拟机, OOM会发生在线程执行过程中</p>
<h2 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h2><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>是方法区的一部分</p>
<p>String::intern(): 如果此String对象的字符串<strong>首次</strong>出现, 则添加到字符串常量池并返回引用, 否则返回该String对象在常量池中的引用</p>
<p>JDK7以前常量池在永久代, 会报PermGen space OOM, JDK7及以上字符串常量池从永久代移到了Java堆中, 会报Java heap space OOM</p>
<p>VM args:</p>
<ul>
<li>-XX: PermSize和-XX: MaxPermSize限制永久代大小</li>
</ul>
<h4 id="方法区-1"><a href="#方法区-1" class="headerlink" title="方法区"></a>方法区</h4><p>存储类型的相关信息, 类名、访问修饰符、常量池、字段描述、方法描述等</p>
<p>JDK 8以前存储在永久代, JDK 8及以后存储在元空间</p>
<p>动态产生类</p>
<ul>
<li> Java SE API的GeneratedConstructorAccessor和动态代理等</li>
<li>CGLib直接操作字节码在运行时生成</li>
<li>JSP第一次运行时需要编译为Java类、基于OSGi的应用</li>
</ul>
<p>VM args: 元空间的防止过多创建动态类的防御防御措施</p>
<ul>
<li>-XX: MaxMetaspaceSize: 指定元空间最大值, 默认-1不指定</li>
<li>-XX: MetaspaceSize: 指定元空间的初始空间大小, 字节为单位. 达到就会进行垃圾收集进行类型卸载, 同时对该值进行修改, 如果释放了大量空间就降低该值, 如果释放了很少空间就提升该值</li>
<li>-XX: MinMetaspaceFreeRatio: 控制垃圾收集之后最小的元空间剩余容量百分比, 减少因为元空间不足导致的垃圾收集频率</li>
</ul>
<h3 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h3><p>直接内存Direct Memory</p>
<p>测试Direct Memory的OOM可以通过Unsafe类的allocateMemory方法在直接内存中分配, 直接内存的OOM产生的Heap Dump文件很小不会有明显的异常</p>
<p>DirectByteBuffer会先计算是否能够分配, 如果不能分配则会在代码手动抛出</p>
<p>常见的间接使用直接内存场景是NIO</p>
<p>VM args:</p>
<ul>
<li>-XX: MaxDirectMemorySize: 直接内存的容量大小, 如果不指定则和Java堆-Xmx一致</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/05/Java-Note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/Java-Note/" class="post-title-link" itemprop="url">Java Note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-05 14:20:57" itemprop="dateCreated datePublished" datetime="2020-09-05T14:20:57+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-06 23:20:24" itemprop="dateModified" datetime="2020-09-06T23:20:24+08:00">2020-09-06</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Filter、Interceptor、Aop实现与区别"><a href="#Filter、Interceptor、Aop实现与区别" class="headerlink" title="Filter、Interceptor、Aop实现与区别"></a>Filter、Interceptor、Aop实现与区别</h1><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>基于函数回调</p>
<p>是 java web 里面的，肯定获取不到 spring 里面 Controller 的信息</p>
<p>应用场景: 过滤请求的特殊字符，防止 SQL 注入</p>
<h3 id="Interceptor、Aspect"><a href="#Interceptor、Aspect" class="headerlink" title="Interceptor、Aspect"></a>Interceptor、Aspect</h3><p>和Spring相关, 能获取到Controller的信息</p>
<ul>
<li><p>Interceptor</p>
<p>AOP的一种运用, 基于 Java 的反射机制</p>
<p>可以使用Spring的依赖注入进行一些业务操作</p>
<p>应用场景：登录检查，请求执行时间等</p>
</li>
</ul>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>过滤前 - 拦截前 - aspect 开始执行- controller逻辑处理 - - aspect 结束 - 拦截后 - 过滤后</p>
<p><img src="/2020/09/05/Java-Note/image-20200905142442832.png" alt="image-20200905142442832"></p>
<h1 id="spring-security"><a href="#spring-security" class="headerlink" title="spring security"></a>spring security</h1><p>Ref: <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7f913e0681fc">https://www.jianshu.com/p/7f913e0681fc</a></p>
<h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成未认证的AuthenticationToken                 </span><br><span class="line">       ↑（获取信息）           （根据AuthenticationToken分配provider）                                    </span><br><span class="line"> AuthenticationFilter   -&gt;     AuthenticationManager    -&gt;    AuthenticationProvider</span><br><span class="line">                                                                      ↓（认证）</span><br><span class="line">                                                              UserDetails（一般查询数据库获取）</span><br><span class="line">                                                                      ↓（通过）</span><br><span class="line">                                                             生成认证成功的AuthenticationToken</span><br><span class="line">                                                                      ↓（存放）</span><br><span class="line">                                                                SecurityContextHolder</span><br></pre></td></tr></table></figure>
<p>自定义流程:</p>
<ul>
<li>自定义AuthenticationFilter、AuthenticationToken、AuthenticationProvider</li>
<li>AuthenticationFilter中生成AuthenticationToken (未认证)并传给AuthenticationManager来验证</li>
<li>AuthenticationProvider通过调用userDetailsService将未认证的Token进行验证并附带Authorities</li>
<li>配置: 实例化filter和provider并添加到Spring security中</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">第五章-创建高性能的索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-03 10:08:55" itemprop="dateCreated datePublished" datetime="2020-09-03T10:08:55+08:00">2020-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-19 22:58:58" itemprop="dateModified" datetime="2021-02-19T22:58:58+08:00">2021-02-19</time>
              </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>索引在存储引擎层实现</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>单列索引:</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200903234444724.png" alt="image-20200903234444724"></p>
<p>多列索引:</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200903234519761.png" alt="image-20200903234519761"></p>
<p>索引查询原则:</p>
<ul>
<li>最左前缀匹配, 从索引定义的最左列开始, 可使用全部或部分列的索引</li>
<li>如果某个列有范围查询, 则其右边的列都无法使用索引</li>
</ul>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>只有Memory引擎支持哈希索引, 也是Memory的默认索引类型.</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>只包含索引值和行指针, 不能用索引值避免读取行</li>
<li>无法用于排序</li>
<li>哈希索引对所有索引列进行hash, 必须使用部分列查索引</li>
<li>只支持=、IN()、&lt;=&gt;, 不支持范围查询</li>
<li>冲突小时查询很快, 冲突严重时查询和删除很慢</li>
</ul>
<p>InnoDB在某些索引值操作频繁时会自发的在B-Tree索引上再创建一个哈希索引 (只是将key进行hash缩短键值, 还是使用B-Tree查找)</p>
<h4 id="不支持哈希索引的存储引擎伪hash索引的实现"><a href="#不支持哈希索引的存储引擎伪hash索引的实现" class="headerlink" title="不支持哈希索引的存储引擎伪hash索引的实现"></a>不支持哈希索引的存储引擎伪hash索引的实现</h4><p>如 (mysql会选择url_crc列):     为什么将长键转为短键能缩短搜索空间???</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200906234559019.png" alt="image-20200906234559019"></p>
<p>对于url_crc列可定义触发器进行维护</p>
<p>WHERE条件需要包含原来的列, 用于处理哈希冲突</p>
<h3 id="空间数据索引-R-Tree"><a href="#空间数据索引-R-Tree" class="headerlink" title="空间数据索引 (R-Tree)"></a>空间数据索引 (R-Tree)</h3><p>用于地理数据索引, 不需要前缀查询, 可以利用任意维度来查询</p>
<p>MyISAM支持</p>
<p>PostgreSQL和PostGIS数据库做的较好</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>对全文的关键词匹配, 和基于值匹配的B-Tree索引不冲突</p>
<p>适用于MATCH AGAINST操作</p>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><p>三个优点:</p>
<ul>
<li>减少扫描的数据量</li>
<li>避免排序和临时表</li>
<li>随机IO变为顺序IO</li>
</ul>
<p>tips:</p>
<ul>
<li>小表全盘扫更高效</li>
<li>中到大型的表用索引很有效</li>
<li>特大表见索引代价高, 考虑分区</li>
<li>表的数量太多, 考虑元数据信息表</li>
</ul>
<h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><h3 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h3><p>索引列不能是表达式的一部分,  也不能是函数的参数</p>
<h3 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h3><p>完整列的选择性: SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;</p>
<p>通常前缀索引的长度应尽量接近完整列的选择性</p>
<p>此外还需要考虑前缀索引每个类型的区分性</p>
<p>前缀索引无法做ORDER BY和GROUP BY</p>
<p>不需要修改表结构</p>
<p>后缀索引可以将字符串反转存储后建立前缀索引 (借助触发器自动触发)</p>
<p>前缀索引创建: ALTER TABLE sakila.city_demo ADD KEY (city(7));</p>
<h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>多个单列的索引在查询条件中使用时, MySQL可能会对OR和AND条件使用UNION和INTERSECTION优化</p>
<p>如下使用了actor_id和film_id两个单列索引, 使用了两个索引扫描的联合:</p>
<p>EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor WHERE actor_id=1 OR film_id=1 \G</p>
<p>Tips:</p>
<ul>
<li>INTERSECTION的存在通常意味着需要联合索引</li>
<li>OR操作往往会合并返回大量数据, 占用大量CPU和内存资源</li>
<li>优化器更在意随机页面读取, 通常会低估查询成本. 使用多列索引消耗更多CPU和内存资源且可能影响并发性. 通常不如直接改写成UNION方式更好</li>
<li>optimizer_switch可便宜关闭索引合并功能</li>
<li>IGNORE INDEX提示优化器忽略掉某些索引</li>
</ul>
<h3 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h3><p>不考虑排序和分组时, 通常考虑将选择性最高的列放在前面</p>
<p>通过多个列的选择性考虑联合索引的顺序 (经验法则):</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200907233137554.png" alt="image-20200907233137554"></p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>数据行和键值紧凑的存储在一起, 一个表只能有一个聚簇索引</p>
<p>InnoDB的聚簇索引:</p>
<ul>
<li>默认主键为聚簇索引</li>
<li>如果没有主键, 会选择一个唯一的非空索引</li>
<li>如果没有这样的索引, 会隐式定义一个逐渐作为聚簇索引</li>
</ul>
<p>InnoDB只聚集同一个页面的记录, 包含相邻键值的页面可能相聚甚远</p>
<p>优点:</p>
<ul>
<li>相关的数据存储在一起. 如根据用户ID为聚簇索引, 该用户的所有邮件只用很少磁盘IO</li>
<li>数据和索引一起存储, 查找快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值 ???</li>
</ul>
<p>缺点:</p>
<ul>
<li>数据量少能放在内存中时, 聚簇索引没什么优势</li>
<li>如果不是按索引顺序插入数据, 可以用OPTIMIZE TABLE重新组织一下表</li>
<li>更新聚簇索引代价高, 被更新的行会被移动到新的位置</li>
<li>插入新行或更新主键会导致“页分裂”问题, 占用更多磁盘</li>
<li>行稀疏或数据存储不连续时, 全表扫描慢</li>
<li>二级索引会存储主键列, 且需要两次查找 (至少)</li>
</ul>
<p>InnoDB自适应的哈希索引能减少二级索引的多次查找???</p>
<h4 id="InnoDB和MyISAM的数据分布对比"><a href="#InnoDB和MyISAM的数据分布对比" class="headerlink" title="InnoDB和MyISAM的数据分布对比"></a>InnoDB和MyISAM的数据分布对比</h4><p>InnoDB主键为聚簇索引, 其他索引为存储主键的二级索引</p>
<p>MyISAM中主键索引和二级索引都存储数据的行号</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200909002342125.png" alt="image-20200909002342125"></p>
<h4 id="在InnoDB表中按主键顺序插入行"><a href="#在InnoDB表中按主键顺序插入行" class="headerlink" title="在InnoDB表中按主键顺序插入行"></a>在InnoDB表中按主键顺序插入行</h4><p>向聚簇索引顺序插入行:</p>
<ul>
<li>新插入的row被顺序写入到磁盘</li>
<li>高并发情况下造成间隙锁竞争</li>
<li>高并发情况下AUTO_INCREMENT锁的影响, 可以调节innodb_autoinc_lock_mode参数改善(ref: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/JiangLe/p/6362770.html">https://www.cnblogs.com/JiangLe/p/6362770.html</a>)</li>
</ul>
<p>向基簇索引插入乱序的行:</p>
<ul>
<li>目标页可能不在磁盘中, 加载会造成许多随机IO</li>
<li>乱序写入有频繁页分裂, 分配新的空间, 一次插入最少需要修改三个页</li>
<li>页分裂使得页变得稀疏, 存在碎片</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>MySQL利用索引列直接获取列数据, 这样就不再需要回表查询读取数据行.</p>
<p>EXPLAIN的EXTRA: using index为使用了覆盖索引</p>
<p>优势:</p>
<ul>
<li>索引比数据行小, 只读取索引能大大减少数据访问量</li>
<li>索引按顺序存储 (至少单页内), 随机IO比读取数据行少</li>
<li>一些存储引擎如MyISAM只缓存索引, 数据则依赖操作系统缓存, 每次访问数据需要一次系统调用, 开销大</li>
<li>InnoDB二级索引中保存了主键值, 可以覆盖对于主键的查询</li>
</ul>
<p>MySQL能在索引中做最左前缀的LIKE比较, 但对于%开头的比较就无法利用索引</p>
<h4 id="使用索引扫描做排序"><a href="#使用索引扫描做排序" class="headerlink" title="使用索引扫描做排序"></a>使用索引扫描做排序</h4><p>使用索引排序的情况:</p>
<ul>
<li>索引的列顺序和ORDER BY子句的顺序完全一致, 并且所有列的排序方向都一样时</li>
<li>ORDER BY子句要求和WHERE的要求一样, 满足索引最左前缀要求. 前导列在WHERE或JOIN子句中指定了常量时, 可以不满足最左前缀要求</li>
<li>需要多表关联时, 只有当ORDER BY子句引用的字段都为第一个表时, 才能用索引做排序. (依赖优化器使用哪张表作为第一张表)</li>
</ul>
<p>EXPLAIN的type: index为使用索引做排序</p>
<p>tips:</p>
<ul>
<li>如果不同列需要按不同方向做排序, 可以将存储该列值进行反转串或相反数</li>
</ul>
<h4 id="压缩-前缀压缩-索引"><a href="#压缩-前缀压缩-索引" class="headerlink" title="压缩(前缀压缩)索引"></a>压缩(前缀压缩)索引</h4><p>MyISAM使用前缀压缩来减少索引大小, 让更多的索引可以放入内存. 默认值只压缩字符串, 通过参数设置页可以对整数做压缩</p>
<p>MyISAM对行指针也采用类似的前缀压缩方式</p>
<p>索引压缩的方法: </p>
<ul>
<li>先完全保存索引块中第一个值, 然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分</li>
<li>如: 索引快第一个值为“perform”, 第二个值是“performace”, 第二个值采用“7,ance”这样的形式</li>
</ul>
<p>优劣:</p>
<ul>
<li>IO密集型应用, 对有些查询带来的好处比成本多很多</li>
<li>因为后一个索引值依赖前一个值, 所以ORDER BY DESC性能不好</li>
<li>CPU密集型应用, 因为需要随机查找, 压缩索引在索引块内的查找是顺序扫描不是二分, 索引性能慢</li>
</ul>
<h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><p>尽量避免冗余和重复索引, 但由于联合索引占空间大, 所以有时为了加速不同query查询会存在冗余索引</p>
<p>为什么前缀压缩的MyISAM使用索引(state_id, city, address)的情况下该语句查询效率比单列索引下降很多呢, 而InnoDB不会???</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200911002700063.png" alt="image-20200911002700063"></p>
<p>分析表中冗余索引和重复索引的方法:</p>
<ul>
<li>复杂的访问INFORMATION_SCHEMA表的查询</li>
<li>Sholomi Noach的common_schema中的一些视图定位, commom_schema是一系列安装到服务器上常用的存储和试图</li>
<li>Percona Toolkit中的pt-duplicate-key-checker工具来检查</li>
</ul>
<h4 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h4><p>不使用索引的查询方式:</p>
<ul>
<li>Percona Server或MariaDB先打开userstates服务器变量 (默认关闭), 查询INFORMATION_SCHEMA.INDEX_STATISTICS查询每个索引的使用频率</li>
<li>Percona Toolkit中的pt-index-usage分析未使用的索引, 并定位质量差的查询, 结果可卸乳MySQL的表中</li>
</ul>
<h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>查询会先通过存储引擎索引过滤返回, 对于索引无法过滤的数据, 存储引擎返回后通过MySQL服务器WHERE子句过滤</p>
<p>如果不使用索引, InnoDB会做全表扫描锁住所有的行</p>
<p>如下例子InnoDB锁定1<del>4行, 但实际上只返回了2</del>4</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200915235347340.png" alt="image-20200915235347340"></p>
<p>InnoDB二级索引使用共享锁, 主键索引使用排他锁. 所以获取写锁的时候无法使用覆盖索引</p>
<h2 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h2><h3 id="支持多种过滤条件"><a href="#支持多种过滤条件" class="headerlink" title="支持多种过滤条件"></a>支持多种过滤条件</h3><p>为了更多使用索引, 创建索引时范围查询应该尽量放在后面, 比如age</p>
<p>有些选择性低但又经常使用到的列可以放在多列索引前面, 如sex、country, 即使在不需要条件SEX的时候也可以通过SEX IN (‘m’, ‘f’) 来使用该多列索引</p>
<p>IN查询能使用索引, MySQL优化器会转化成=进行组合, 如下查询就有4x3x2=24种组合</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200916102912749.png" alt="image-20200916102912749"></p>
<h3 id="避免多个范围条件"><a href="#避免多个范围条件" class="headerlink" title="避免多个范围条件"></a>避免多个范围条件</h3><p>范围查询会使得右侧的索引失效, 所以一个查询种范围查询应该尽量少.</p>
<p>可以考虑如何优化查询替代存在多个范围条件的问题, 如下查询可以通过新增active列替代过去几周上线过的用户条件(last_online), 该字段通过定时任务去维护</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200917002440338.png" alt="image-20200917002440338"></p>
<p>tips: EXPLAIN不能分辨范围查询和IN查询, 都会显示type为range, 但是这两种查询的访问效率是不同的</p>
<h3 id="优化排序"><a href="#优化排序" class="headerlink" title="优化排序"></a>优化排序</h3><p>数据集大的时候使用文件排序是很慢的</p>
<p>即使有索引(sex, rating), limit偏移很大的查询也会很慢, 案例:</p>
<p><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200917003431012.png" alt="image-20200917003431012"></p>
<p>优化方法:</p>
<ul>
<li>反范式化、预先计算、缓存</li>
<li>限制翻页数量</li>
<li>延迟关联: 使用覆盖索引查询主键, 再根据这些主键获取需要的行<ul>
<li><img src="/2020/09/03/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/image-20200917003658355.png" alt="image-20200917003658355"></li>
<li>不懂这里为啥原查询不会直接先查主键再回表???</li>
</ul>
</li>
</ul>
<h2 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/01/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-01 01:07:38 / 修改时间：01:16:57" itemprop="dateCreated datePublished" datetime="2020-09-01T01:07:38+08:00">2020-09-01</time>
            </span>

          
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/image-20200901011436208.png" alt="image-20200901011436208"></p>
<p><img src="/image-20200901011636497.png" alt="image-20200901011636497"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Max"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Max</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dongrongyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dongrongyu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rongyu.dong@gmail.com" title="E-Mail → mailto:rongyu.dong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Max</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '3nDJCTt3PoQ9qeabywtgL5qQ-gzGzoHsz',
      appKey     : 'HMGLSYCgLRuL0Tst8VMocAfj',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
