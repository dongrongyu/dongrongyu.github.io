<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dongrongyu.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="程序计数器、虚拟机栈、本地方法栈分配内存在编译期可知, 随着方法结束或线程结束内存被回收 Java堆和方法区的内存分配具有不确定性, 是内存分配与回收的主要讨论方面 对象已死?引用计数算法Reference counting, 每个对象用一个计数器来判断对象的存活情况 需要许多额外工作保证该算法正确的工作, 譬如: 难以处理对象之间循环引用的问题 可达性分析算法通过GC Roots中的根对象作为起">
<meta property="og:type" content="article">
<meta property="og:title" content="第3章-垃圾收集器和内存分配策略">
<meta property="og:url" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="Max&#39;s BigHouse">
<meta property="og:description" content="程序计数器、虚拟机栈、本地方法栈分配内存在编译期可知, 随着方法结束或线程结束内存被回收 Java堆和方法区的内存分配具有不确定性, 是内存分配与回收的主要讨论方面 对象已死?引用计数算法Reference counting, 每个对象用一个计数器来判断对象的存活情况 需要许多额外工作保证该算法正确的工作, 譬如: 难以处理对象之间循环引用的问题 可达性分析算法通过GC Roots中的根对象作为起">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200924102412342.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928195908139.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928234101400.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120232896.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120706248.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929154351247.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929155628297.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929160844578.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929162601589.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929164608367.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929165537962.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929173655549.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929174133829.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929175220239.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930004721338.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930005222909.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019153724892.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160542645.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160603709.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019161007965.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019162035357.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019170904557.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019182007284.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019183401317.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019195358982.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005314958.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005346874.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220853939.png">
<meta property="og:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220910121.png">
<meta property="article:published_time" content="2020-09-22T15:30:26.000Z">
<meta property="article:modified_time" content="2021-02-09T05:55:22.846Z">
<meta property="article:author" content="Max">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200924102412342.png">

<link rel="canonical" href="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>第3章-垃圾收集器和内存分配策略 | Max's BigHouse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Max's BigHouse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学有所依</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dongrongyu.github.io/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Max">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Max's BigHouse">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          第3章-垃圾收集器和内存分配策略
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-22 23:30:26" itemprop="dateCreated datePublished" datetime="2020-09-22T23:30:26+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-09 13:55:22" itemprop="dateModified" datetime="2021-02-09T13:55:22+08:00">2021-02-09</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>程序计数器、虚拟机栈、本地方法栈分配内存在编译期可知, 随着方法结束或线程结束内存被回收</p>
<p>Java堆和方法区的内存分配具有不确定性, 是内存分配与回收的主要讨论方面</p>
<h1 id="对象已死"><a href="#对象已死" class="headerlink" title="对象已死?"></a>对象已死?</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>Reference counting, 每个对象用一个计数器来判断对象的存活情况</p>
<p>需要许多额外工作保证该算法正确的工作, 譬如: 难以处理对象之间循环引用的问题</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>通过GC Roots中的根对象作为起始节点, 从这些节点开始建立对象的引用链. 如果对象没有一条路径到达GC Roots, 则这个对象是不可达的.</p>
<p>该算法被用于Java、C#、Lisp等语言的内存管理</p>
<p>GC Roots的对象:</p>
<ul>
<li><strong>虚拟机栈</strong> (栈帧中的本地变量表) 中引用的对象, 如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li><strong>方法区中类静态属性引用的对象</strong>, 如Java类的引用类型静态变量</li>
<li><strong>方法区中常量引用的对象</strong>, 如字符串常量池中的引用</li>
<li><strong>本地方法栈JNI (Native方法)引用的对象</strong></li>
<li><strong>Java虚拟机内部的引用</strong>, 如基本数据类型的Class对象, 一些常驻的异常对象, 比如NullPointerException、OutOfMemoryError等</li>
<li><strong>所有被同步锁 (Synchronized关键字) 持有的对象</strong></li>
<li>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
<li>根据垃圾收集器的不同, 还有其他对象“临时性”的加入. 如针对Java堆的某一块区域的垃圾收集需要考虑是否与其他区域关联 (记忆集)</li>
</ul>
<h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>强引用String Reference: 代码中存在的引用关系, 即Object obj = new Object(), 垃圾收集器永远不会收集强引用对象</p>
<p>软引用SoftReference: 系统要发生溢出异常前会将这些对象列进回收范围进行回收, 如果还没有足够空间才会抛出内存溢出异常. SoftReference来实现</p>
<p>弱引用WeakReference: 只能生存到下一次垃圾收集发生. WeakReference类来实现</p>
<p>虚引用: 不对对象生存时间构成影响, 只为了在对象被收集时得到一个系统通知. PhantomReference类来实现</p>
<h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡?"></a>生存还是死亡?</h2><p>对象销毁的两次标记过程:</p>
<ol>
<li>可达性分析后发现没有与GC Roots相连接的引用链</li>
<li>如果没有覆盖finalize()方法或finalize()方法已经被调用过, 只会被<u>调用一次</u></li>
</ol>
<p>如果需要执行finalize()方法, 对象将被放入F-Queue的队列中, 之后由虚拟机自动建立的、<strong>低调度优先级</strong>的Finalizer线程去执行. 虚拟机会触发刚方法的运行, 但不一定会等待它运行结束(防止长时间等待).</p>
<p>finalize()中若重新和引用链进行关联, 则可以不被回收 (只可逃脱一次), 如:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200924102412342.png" alt="image-20200924102412342"></p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区(HotSpot虚拟机中的元空间或者永久代)的回收比较严苛, 《Java虚拟机规范》并不要求方法区必须实现垃圾回收</p>
<p>主要回收: 废弃的常量、不再使用的类型</p>
<p>废弃常量的条件: 如字符串“java”进入常量池但没有任何对象引用该常量, 虚拟机也没有引用</p>
<p>不再使用的类条件: </p>
<ul>
<li>该类的所有实例或其派生子类的实例都已被回收</li>
<li>加载该类的类加载器已经被回收 (通常很难达成, 除非是经过精心设计的可替换类加载器的场景如OSGi、JSP的重加载等)</li>
<li>该类对应的java.lang.Class对象没有再任何地方被引用 (无法在任何地方通过反射访问该类的方法)</li>
</ul>
<p>大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义类加载器的场景中, 需要JVM具备类型卸载能力, 以免对方法区造成过大内存压力</p>
<p>VM args:</p>
<ul>
<li>-Xnoclassgc: 控制虚拟机是否对类型进行回收</li>
<li>-verbose:class、-XX:+TraceClass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息 (-XX:+TraceClassUnLoading需要FastDebug版虚拟机)</li>
</ul>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>两种方法: 引用计数式垃圾收集Reference Counting GC、追踪式垃圾收集Tracing GC, 也被称为直接式垃圾收集和间接式垃圾收集</p>
<p>本节内容均属于追踪式</p>
<h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>基于两个假说+一个用于解决跨代引用问题的经验法则:</p>
<ul>
<li>弱分代假说Weak Generatioal Hypothesis: 绝大多数对象都是朝生夕灭的</li>
<li>强分代假说Strong Generation Hypothesis: 熬过越多次垃圾收集过程的对象越难以消亡</li>
<li>跨带引用假说Intergenerational Reference Hypothesis: 跨带引用相对于同代引用来说仅占极少数</li>
</ul>
<p>新生代Young Generation: 每次收集会有大批对象死去, 每次回收后存活的少量对象, 将会逐步晋升到老年代中存放</p>
<p>老年代Old Generation: </p>
<p>依据跨带引用假说, 为了解决跨代引用问题, 需要在新生代上建立一个全局的数据结构记忆集Remembered Set</p>
<ul>
<li>该结构把老年代划分成若干小块, 标识出老年代哪一块内存会存在跨代引用, 此后Minor GC时需要将这些对象加入GC Roots</li>
<li>在对象改变引用关系时需要维护数据正确性</li>
</ul>
<p>一些GC名词:</p>
<ul>
<li>部分收集Partial GC, 目标不是收集整个Java堆的GC<ul>
<li>新生代收集Minor GC/Young GC</li>
<li>老年代收集Major GC/Old GC: 目前只有CMS收集器存在Old GC</li>
<li>混合收集Mixed GC: 目标是收集整个新生代和部分老年代的GC, 只有G1收集器有这种行为</li>
</ul>
</li>
<li>整堆收集Full GC: 收集整个Java堆和方法区</li>
</ul>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>Mark-Sweep算法, 包括标记+清除两个阶段</p>
<p>可以标记需要GC的对象也可以标记存活的对象, 然后执行清除需要GC的对象</p>
<p>缺点:</p>
<ul>
<li>执行效率不稳定. 如果Java堆中包含大量对象, 且大部分需要被回收, 这时标记和清除两个过程的执行效率随对象数量的增长大大降低</li>
<li>内存碎片化</li>
</ul>
<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>解决标记-清除算法存在的问题</p>
<p>将内存区域划分为相等的两块, GC时将存活的对象复制到另一块半区, 同时清理之前用的半区</p>
<p>改算法被主流的商用Java虚拟机新生代GC采用</p>
<p>Appel式回收 (Andrew Appel 1989年提出) 的Hotspot实现:</p>
<ul>
<li>一个Eden区+两个Survivor区</li>
<li>Eden和Survivor空间大小比例8:1</li>
<li>每次GC时将Eden区和Survivor区中存活的对象复制到另一块Survivor区中</li>
<li>每次新生代可用内存空间为容量的90%</li>
<li>分配担保Handle Promotion: 当Survivor空间不足以容纳一次Minor GC的存活对象时, 这些对象将直接进入老年代</li>
</ul>
<p>缺点:</p>
<ul>
<li>对象存活率高时需要较多复制操作, 不适用于老年代</li>
</ul>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>Mark-Compact算法, 类似标记-清除算法, 但是会将存活对象整理存放到一起解决内存碎片问题.</p>
<p>相比Mark-Sweep算法的优缺:</p>
<ul>
<li>GC时间长, 包括内存的复制过程</li>
<li>没有内存碎片问题</li>
<li>Mark-Sweep算法在内存碎片导致无法分配大对象时可能采取“分区空闲分配链表” 解决内存分配问题 (类似于磁盘存储大文件), 会是的分配和访问效率低. Mark-Compact则没这个问题</li>
</ul>
<p>一些垃圾收集器可能会结合使用Mark-Sweep和Mark-Compact</p>
<h1 id="HotSpot算法细节实现"><a href="#HotSpot算法细节实现" class="headerlink" title="HotSpot算法细节实现"></a>HotSpot算法细节实现</h1><h2 id="根结点枚举"><a href="#根结点枚举" class="headerlink" title="根结点枚举"></a>根结点枚举</h2><p>GC Roots节点主要为全局性引用 (常量或类静态属性)与执行上下文(栈帧的本地变量表)</p>
<p>根结点枚举的过程必须暂停用户线程</p>
<p>虚拟机其实并不需要一个不漏的从方法区等GC Roots获取哪些地方存放着对象引用的, 虚拟机是可以直接得到哪些地方存放着对象引用的. HotSpot通过OopMap (Ordinary Object Pointer)记录, 在类加载动作完成, 会把对象什么偏移量上是什么类型的数据计算出来, 即使是即使编译, 也会在某个位置记录下栈里和寄存器哪些位置是引用.</p>
<p>???不太懂</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928195908139.png" alt="image-20200928195908139"></p>
<p>OopMap是针对指令的数据结构, 会为某条特定位置的指令生成</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>Safepoint, 用于生成OopMap的特定位置, 也是发生GC的指令位置, 避免对每条指令生成造成过多存储空间浪费. 设立不能太短也不能太长</p>
<p>安全点的选取以“是否具有让程序长时间执行的特征”为标准, 例如方法调用、循环跳转、异常跳转等指令序列复用的位置</p>
<p>让所有线程(其实不包括JNI调用的线程)跑到安全点停下的方式:</p>
<ul>
<li>抢先式中断Preemptive Suspension, 现有虚拟机一般不采用<ul>
<li>垃圾收集式, 系统让用户线程全部中断, 如果发现有用户线程不在安全点上则恢复其执行过一会再中断, 直到跑到安全点</li>
</ul>
</li>
<li>主动式中断Voluntary Suspension<ul>
<li>设一个标志位, 各个线程执行过程中不断轮训, 一旦发现标志位true则再最近安全点上主动挂起</li>
<li>轮询位置: 安全点 + 所有创建对象和其他需要再Java堆上分配内存的地方</li>
<li>HotSpot使用内存保护陷阱方式实现<ul>
<li>一条汇编指令</li>
<li>预先注册异常处理器, 需要用户线程暂停时置0x160100内存页为不可读, test指令则发生自陷异常信号, 线程挂起等待</li>
<li><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200928234101400.png" alt="image-20200928234101400"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>Safe Region, 引用关系不会发生变化的代码片段, 虚拟机可以不需要等待在安全区域中的线程</p>
<p>用于避免线程处于Sleep状态或Blocked状态的情况</p>
<p>线程离开安全区域时, 需要检查虚拟机是否完成了根节点枚举(或暂停其他用户线程的阶段), 如果还未完成则需等待信号, 否则直接继续执行.</p>
<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><p>记忆集Remembered Set: 用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
<p>记录精度:</p>
<ul>
<li>非收集区域的所有跨代引用对象数组, 空间占用和维护成本高<ul>
<li><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120232896.png" alt="image-20200929120232896"></li>
</ul>
</li>
<li>字长精度: 精确到一个机器字长, 记录该字包含跨代指针</li>
<li>对象精度: 精确到一个对象, 该对象有跨代指针的字段</li>
<li>卡精度: 一块内存区域, 改区域内有对象含有跨代指针</li>
</ul>
<p>卡精度为最常用的记忆集实现方式, 通过卡表Card Table方式实现记忆集.</p>
<p>卡表: </p>
<ul>
<li><p>字节数组</p>
<ul>
<li>CARD_TABLE [this address &gt;&gt; 9] = 0;</li>
</ul>
</li>
<li><p>如果卡页中有对象存在跨代引用, 则标识为1</p>
</li>
<li><p>每个元素都对应标识内存区域一块特定大小的内存块(卡页), 如上代表2^9=512字节</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929120706248.png" alt="image-20200929120706248"></p>
</li>
</ul>
<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>写屏障Write Barrier: 维护卡表状态的技术, 可以看作虚拟机层面对“引用类型字段赋值”的AOP操作, 这个操作会被编译器放到每一个赋值操作之中.</p>
<p>对引用对象赋值产生一个Around通知, 执行额外动作. 又分为写前屏障Pre-Write Barrier和写后屏障Post-Write Barrier. 除了G1收集器, 其他收集器都只用到了写后屏障</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929154351247.png" alt="image-20200929154351247"></p>
<p>写屏障会带来赋值时的额外开销, 不过相比Minor GC扫描整个老年代要低得多</p>
<p>伪共享问题False Sharing: 多个线程对属于同一Cache line的卡表元素操作时由于缓存一致性同步导致的性能降低</p>
<p>伪共享问题可通过修改前判断来降低影响</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929155628297.png" alt="image-20200929155628297"></p>
<p>VM args:</p>
<ul>
<li>-XX:+UseCondCardMark: 用来决定是否开启卡表更新的条件判断</li>
</ul>
<h2 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h2><p>用户线程和收集器并发工作带来的问题:</p>
<ul>
<li>原本消亡的对象标记为存活. 可以容忍</li>
<li>原本存活的对象标记为消亡 (对象消失). 不可产生</li>
</ul>
<p>三色标记:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929160844578.png" alt="image-20200929160844578"></p>
<p>“对象消失” 的条件 (1994, Wilson):</p>
<ol>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ol>
<p>“对象消失”的解决方案:</p>
<ul>
<li>增量更新(Incremental Update): 破坏条件一, 黑色对象插入白色对象引用时, 将这个新插入的引用记录下来, 收集结束后, 再将这些引用关系中的黑色对象标记为灰色, 重新扫描一次</li>
<li>原始快照(Snapshot At The Beginning): 破坏条件二, 灰色对象要删除指向白色对象的引用关系时, 记录这个删除的引用, 在扫描结束时, 将这些对象标记为灰色, 重新扫描. 其实就是按刚开始扫描的引用结构搜索</li>
</ul>
<p>增量更新: CMS</p>
<p>原始快照: G1、Shenandoah</p>
<h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><p>“经典” : &gt;=JDK 7 Update 4, &lt;JDK11</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929162601589.png" alt="image-20200929162601589"></p>
<p>JDK 9时图中两种收集器组合被废弃</p>
<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>最基础的、历史悠久的收集器. 仍是HotSpot虚拟机运行在客户端模式下的默认新生代收集器</p>
<p>单线程收集器, 工作时必须暂停其他所有工作线程</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929164608367.png" alt="image-20200929164608367"></p>
<p>优缺:</p>
<ul>
<li>简单而高效</li>
<li>额外内存消耗少</li>
<li>单核处理器或核心数少的环境来说, 比较高效</li>
<li>适用于桌面应用场景和部分微服务应用</li>
</ul>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>Serial收集器的多线程并行版本, 除了GC时候使用多线程, 其余都和Serial相同</p>
<p>新生代收集器</p>
<p>ParNew + Serial Old:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929165537962.png" alt="image-20200929165537962"></p>
<p>主要在JDK 5中用于和CMS搭配使用</p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>新生代收集器, 使用标记-复制算法, 和ParNew类似</p>
<p>Parallel Scavenge收集器主要关注吞吐量, 又称为吞吐量收集器, 目的在于控制垃圾收集时间占程序总执行时间的比例.</p>
<p>自适应调节策略(GC Ergonomics)来动态调整Java堆上各个分代空间的分配</p>
<p>VM args:</p>
<ul>
<li>-XX:MaxGCPauseMills: 一次GC允许的最长时间的ms.</li>
<li>-XX:GCTimeRatio: 允许的最大垃圾收集时间比例, 设定为x时, 最大垃圾收集时间占总时间的1/(1+x)</li>
<li>-XX:+UseAdaptiveSizePolicy: 自适应调节策略, 启用后不再需要指定新生代大小(-Xmn)、Eden与Survivor的比例(-XX:SurvivorRatio)、晋升老年代对象大小(-XX:PretenureSizeThreshold)等细节参数, Parallel Scavenge收集器会根据运行时监控信息动态调整以提供<u>最合适的停顿时间</u>和<u>最大的吞吐</u></li>
</ul>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial的老年代版本, 单线程收集器, 使用标记-整理算法</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929173655549.png" alt="image-20200929173655549"></p>
<p>使用场景:</p>
<ul>
<li>客户端模式的HotSpot虚拟机使用</li>
<li>&lt;=JDK 5时搭配Parallel Scavenge收集器使用</li>
<li>CMS发生Concurrent Mode Failure时使用</li>
</ul>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>JDK 6提供, Parallel Scavenge收集器的老年代版本, 并发收集, 使用标记-整理算法</p>
<p>主要用于和Parallel Scavenge的搭配使用</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929174133829.png" alt="image-20200929174133829"></p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS (Concurrent Mark Sweep)以获取最短回收停顿时间为目标的收集器, 使用标记-清除算法. 总体上来说为并发收集器</p>
<p>执行步骤:</p>
<ol>
<li>初始标记 (CMS initial mark)</li>
<li>并发标记 (CMS cocurrent mark)</li>
<li>重新标记 (CMS remark)</li>
<li>并发清除 (CMS concurrent sweep)</li>
</ol>
<p>其中1、3需要停顿用户线程, 通常3执行时间大于1, 2、4耗时时间最长</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200929175220239.png" alt="image-20200929175220239"></p>
<p>三个明显缺点:</p>
<ul>
<li>处理器资源敏感: 默认回收线程数为(处理器核心数+3)/4, 核心数&gt;4时, 占用约为25%的处理器运算资源, &lt;4时影响较大. 增量式并发收集器i-CMS使得用户线程可以和垃圾收集线程在一个核心交替执行缓解该问题, 但效果不好在JDK 9废弃</li>
<li>无法处理“浮动垃圾” (FLoating Garbage), 出现“Concurrent Mode Failure”: 由于2、4阶段用户线程在运行可能产生垃圾, 如果预留的内存空间无法满足分配新对象的需求, 会出现“Concurrent Mode Failure”, 此时会启用Serial Old收集器执行一次暂停用户线程执行GC.</li>
<li>内存碎片: Mark-Sweep算法导致, 无法分配时会导致Full GC. Full GC需要完全停止用户线程执行. 可以通过两个参数调节</li>
</ul>
<p>VM args:</p>
<ul>
<li>-XX:CMSInitiatingOccupancyFraction: 执行CMS时老年代的使用空间比例</li>
<li>-XX:+UseCMSCopmpactAtFullCollection: 在FUll GC时进行内存整理, JDK 9废弃</li>
<li>-XX:CMSFullGCsBeforeCompation: 执行若干次不整理空间的Full GC后, 下一次进入Full GC前会先进行碎片整理, 默认为0. JDK 9废弃</li>
</ul>
<h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>G1收集器, JDK 7提出. JDK 9替代Parallel Scavenge+Parallel Old组合成为默认收集器, CMS成为Deprecate, 但由于历史遗留, 规划在JDK 10提出“统一垃圾收集器接口”.</p>
<p>基于Region的堆内存布局:</p>
<ul>
<li>连续的Java堆被划分成多个大小相等的独立区域Region, 每个Region都可以根据需要扮演新生代的Eden空间、Survivor空间或者老年代空间</li>
<li>Humongous区域: <ul>
<li>专门用来存储大对象, G1大多数行为都把Humongous Region作为老年代的一部分来看待.</li>
<li>只要大小超过一个Region容量的一半则可视为大对象</li>
<li>超过整个Region容量的超级大对象, 会放在N个连续的Humongous Region之中</li>
<li>-XX:G1HeapRegionSize: 1MB~32MB, 每个region的大小</li>
</ul>
</li>
</ul>
<p>G1收集器对内存任何部分组成的回收集Collection Set (CSet) 来进行回收, 不再针对分代, 而是哪块内存的垃圾数量多, 回收收益最大</p>
<p>G1对扮演不同角色的Region采用不同的策略去处理</p>
<p>G1是一个“<strong>停顿时间模型</strong>”的收集器</p>
<ul>
<li>建立起可预测的停顿时间模型是因为以Region为单次回收的最小单元</li>
<li>每次收集的内存空间都是Region大小的整数倍</li>
<li>避免在整个Java堆中进行全区域垃圾收集</li>
<li>依赖垃圾堆积的“价值”大小建立<strong>优先级列表</strong>, 在允许的停顿时间 (-XX:MaxGCPauseMillis) 内优先处理收益最大的Region</li>
<li>“价值”: 回收所获的的空间大小以及回收所需时间的经验值</li>
</ul>
<p>G1设计的细节问题:</p>
<ul>
<li>跨Region的引用对象如何解决: <ul>
<li>每个region维护自己的记忆集, 这些记忆集记录别的region指向自己的卡页范围.</li>
<li>记忆集的实现通过一个哈希表, Key是别的Region的起始地址, Value是一个集合, 里面存储的元素是卡表的索引号.</li>
<li>Region数量比传统分代数量多的多, G1至少要耗费Java堆容量的10%~20%额外内存来维持收集器工作</li>
</ul>
</li>
<li>收集线程如何与用户线程并发执行:<ul>
<li>G1通过原始快照SATB算法来实现</li>
<li>每个Region有两个TAMS (Top at Mark Start) 指针, 新分配对象地址必须在这两个指针位置以上, 即它们是默认存活不纳入回收范围</li>
<li>如果回收速度赶不上分配速度, 也会导致Full m GC冻结用户线程执行</li>
</ul>
</li>
<li>怎样建立可靠的停顿预测模型:<ul>
<li>-XX:MaxGCPauseMillis: 指定停顿时间</li>
<li>G1会统计每个Region的回收耗时、每个Region记忆集里脏卡数量等各个可测量步骤花费的成本, 分析得出衰减平均值 (更准确代表“最近”的平均状态)、标准偏差、置信度等统计信息, 通过这些信息预测现在开始回收哪些Region组成的回收集可以在不超过期望停顿时间内获得最高的收益</li>
</ul>
</li>
</ul>
<p>G1收集器的四个步骤:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930004721338.png" alt="image-20200930004721338"></p>
<p>只有在并发标记阶段是并发的, G1的主要目标时间延迟可控的情况下获得尽可能高的吞吐, “全功能收集器”</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20200930005222909.png" alt="image-20200930005222909"></p>
<p>停顿时间设置的过小会使得回收赶不上内存分配导致Full GC</p>
<p>G1设计上更注重能够应付内存分配速率 (Allocation Rate) 而不追求一次把Java堆全部清理干净</p>
<p>G1和CMS对比:</p>
<ul>
<li>G1可以指定对打停顿时间、分Region内存布局、通过“价值”确定回收集</li>
<li>G1收集不会产生内存碎片, CMS会因内存碎片导致Full GC</li>
<li>G1内存占用和执行负载高</li>
<li>G1每个Region都需要一个卡表, CMS只有新生代有一个卡表. 都通过写后屏障维护</li>
<li>G1使用原始快照搜索SATB算法, 写前屏障来实现指针引用的变化, 避免最终标记阶段时间过长. CMS通过增量算法. 增量算法为什么不需要写前屏障呢???</li>
<li>G1写屏障操作复杂, 放入队列进行异步处理. CMS写屏障同步处理</li>
</ul>
<p>通常CMS在小内存上表现会优于G1, 大内存上G1性能更好</p>
<h2 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h2><p>Red hat写的收集器, Oracle G1收集器的继承者, 只在OpenJDK中包含, 被OracalJDK通过条件编译排除</p>
<p>为程序执行提供低延迟的GC停顿时间, 高运行负担情况下吞吐量低于G1、CMS和Parallel Scavenge. 据表3-2的测试结果</p>
<p>相比G1:</p>
<ul>
<li>基于Region的对内存管理</li>
<li>支持并发的整理算法</li>
<li>不使用分代收集 (并不是说分代收集对Shenandoah没有价值)</li>
<li>使用连接矩阵(Connection Matrix), 而不是用G1的记忆集实现方式</li>
</ul>
<p>连接矩阵Connection Matrix: 降低了记忆集维护消耗, 也降低了伪共享问题</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019153724892.png" alt="image-20201019153724892"></p>
<p>步骤:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160542645.png" alt="image-20201019160542645"></p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019160603709.png" alt="image-20201019160603709"></p>
<p><strong>三个重要阶段</strong>: 并发标记、并发回收、并发引用更新</p>
<p>工作流程:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019161007965.png" alt="image-20201019161007965"></p>
<h3 id="Brooks-Pointer"><a href="#Brooks-Pointer" class="headerlink" title="Brooks Pointer"></a>Brooks Pointer</h3><p>原始的转发指针操作实现:</p>
<ul>
<li>步骤:<ol>
<li>在被移动对象的原有内存上设置Memory Protection Trap</li>
<li>访问旧对象时的内存空间时产生自陷中断, 调用异常处理器</li>
<li>将代码访问转发到复制后的新对象上</li>
</ol>
</li>
<li>缺点: 如果没有操作系统支持, 这种方案导致用户态频繁切换到核心态, 代价高</li>
</ul>
<p>Brooks Pointer (Forward Pointer):</p>
<ul>
<li><p>方案: </p>
<ul>
<li>在对象头部增加Brooks Pointer</li>
<li>没有Memory Protection Trap的问题, 但是对像访问多了一次间接跳转</li>
</ul>
</li>
<li><p>对象未被移动时:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019162035357.png" alt="image-20201019162035357"></p>
</li>
<li><p>被移动后:</p>
</li>
</ul>
<p>并发写Brooks Pointer:</p>
<ul>
<li><p>问题:</p>
<ol>
<li><p>收集器线程复制了对象</p>
</li>
<li><p>用户线程更新对象某个字段     –&gt; 写在旧对象上</p>
</li>
<li><p>收集器线程更新转发指针的引用为新副本地址</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019170904557.png" alt="image-20201019170904557"></p>
</li>
</ol>
</li>
<li><p>解决方式: Shenandoah收集器通过CAS保证并发对象访问的正确性</p>
</li>
</ul>
<p>为了实现Brooks Pointer, Shenandoah在读、写屏障中都加入了额外的转发处理</p>
<p>基于引用访问屏障 Load reference Barrier:</p>
<ul>
<li>为了减少读屏障对访问带来的问题, 计划在JDK 13中引入</li>
<li>只拦截对象中数据类型为引用类型的读写操作, 而不去管原声数据类型等其他非引用字段的读写</li>
</ul>
<h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>PGC和G4收集器的继承者</p>
<p>ZGC特征:</p>
<ul>
<li>基于Region内存布局</li>
<li>(暂时)不设分代</li>
<li>使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法</li>
<li>以低延迟为首要目标</li>
</ul>
<p>ZGC的Region (Page、ZPage): 具有动态性 (动态创建和销毁、动态容量大小)</p>
<ul>
<li>Small Region: 2MB, 放置&lt;256KB的小对象</li>
<li>Medium Region: 32MB, 放置&gt;=256KB但&lt;4MB的对象</li>
<li>Large Region: 容量动态变化, 为2MB的整数倍. 放置4MB及以上的<u>一个</u>大对象 (所以large region可能小雨medium region). 由于拷贝开销大, Large region在ZGC中不会被重分配</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019182007284.png" alt="image-20201019182007284"></p>
<h3 id="染色指针-Colored-Pointer、Tag-Pointer、Version-Pointer"><a href="#染色指针-Colored-Pointer、Tag-Pointer、Version-Pointer" class="headerlink" title="染色指针 (Colored Pointer、Tag Pointer、Version Pointer)"></a>染色指针 (Colored Pointer、Tag Pointer、Version Pointer)</h3><p>在对象引用上记录信息的一项技术</p>
<p>64位系统 -&gt; AMD架构只支持48位虚地址空间 -&gt; 64位Linux支持47位需地址空间和46位物理地址空间</p>
<p>46位地址空间仍然过剩, 所以取高4位来存储四个标志信息:</p>
<ul>
<li>对象三色标记状态</li>
<li>是否进入了重分配集 (即被移动过)</li>
<li>是否只能通过finalize()方法才能访问到</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019183401317.png" alt="image-20201019183401317"></p>
<p>缺点:</p>
<ul>
<li>4TB的内存限制</li>
<li>不能支持32位平台</li>
<li>不能支持压缩指针(-XX:+UseCompressedOops)</li>
<li>……</li>
</ul>
<p>优势:</p>
<ul>
<li>Region存活对象被移走之后, 这个Region能立即释放, 而不用等到整个堆中所有指向该Region的引用都被修正</li>
<li>大幅减少读、写屏障的使用量. 使用内存屏障目的时记录对象引用变化情况, 但这些信息直接维护在指针中了. ZGC只使用了读屏障 (原因是染色指针和不支持分代) </li>
<li>可以作为一种扩展结构记录更多与对象标记、重定位过程相关的数据, 用以提高性能. 譬如记录低频访问对象, 转移到不常访问的内存区域</li>
</ul>
<p>多重映射 (Multi-Mapping):</p>
<ul>
<li>LInux/x86-64平台上ZGS使用多重映射将不同的虚拟地址映射到同一物理地址上</li>
<li>多重映射技术是怎么实现的呢???</li>
</ul>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201019195358982.png" alt="image-20201019195358982"></p>
<h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005314958.png" alt="image-20201020005314958"></p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020005346874.png" alt="image-20201020005346874"></p>
<p>理解: </p>
<ul>
<li>并发标记阶段的GC Roots应该不包括跨region的指针. 在并发预备重分配中会扫描其他所有region来定位跨region指针指向重分配集中的对象.</li>
<li>重分配的时候应该对对象的所有引用指针进行染色, 这个过程应该是原子操作的, 应该也会造成停顿时间???</li>
</ul>
<h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><p>没有使用记忆集、分代, 因此不需要写屏障, 但GC时间长, 能承受的对象分配速率不会太高 (解决该问题的根本方法是分代收集, 针对新生代进行更频繁、更快的收集)</p>
<p>NUMA-aware的内存分配. 在ZGA之前只有Parallel Scavenge支持NUMA-aware内存分配</p>
<p>GC过程低延迟, 吞吐量也比较高能达到Parallel Scavenge的90% (根据图3-23结果)</p>
<h1 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h1><h2 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h2><p>JDK 10开始, 为了隔离垃圾收集器堉Java虚拟机解释、编译、监控等子系统的关系, RedHat提出了垃圾收集的统一接口, Epsilon是这个接口的有效性验证和参考实现</p>
<p>不干活的收集器</p>
<p>用于剥离垃圾收集器影响的性能测试和压力测试</p>
<p>用于不需要垃圾收集就会推出的极小应用</p>
<h2 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h2><h2 id="虚拟机及垃圾收集器日志"><a href="#虚拟机及垃圾收集器日志" class="headerlink" title="虚拟机及垃圾收集器日志"></a>虚拟机及垃圾收集器日志</h2><p>JDK 9之后所有日志都可以利用-Xlog参数统一输出格式</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220853939.png" alt="image-20201020220853939"></p>
<p>日志支持的所有模块:</p>
<p><img src="/2020/09/22/%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20201020220910121.png" alt="image-20201020220910121"></p>
<h2 id="垃圾收集器参数总结"><a href="#垃圾收集器参数总结" class="headerlink" title="垃圾收集器参数总结"></a>垃圾收集器参数总结</h2><h1 id="实战-内存分配与回收策略"><a href="#实战-内存分配与回收策略" class="headerlink" title="实战: 内存分配与回收策略"></a>实战: 内存分配与回收策略</h1><p>概念上来讲, 对象应该都在堆上分配 (实际上可能经过即时编译后被拆散成标量类型并间接地在栈上分配)</p>
<h2 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h2><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>-XX:PretenureSizeThreshold, 指定大于该设置值的对象直接在老年代分配</p>
<h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>-XX:MaxTenuringThreshold, 对象晋升老年代的年龄阈值</p>
<h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>发生Minor GC前, 先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</p>
<p>​    条件成立, 这一次Minor GC是安全的</p>
<p>​    条件不成立, 查看-XX:HandlePromotionFailure参数设置值是否允许担保失败</p>
<p>​        允许, 检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小</p>
<p>​            成立, 尝试一次Minor GC, 此次Minor GC有风险</p>
<p>​            不成立, 进行Full GC</p>
<p>​        不允许, 可进行Full GC</p>
<p>JDK 6 Update 24之后-XX:HandlePromotionFailure不再使用, 规则变为只要老年代连续空间大于新生代对象总大小或历次晋升的平均大小, 就会进行Minor GC, 否则进行Full GC</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/17/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" rel="prev" title="第2章-Java内存区域与内存溢出异常">
      <i class="fa fa-chevron-left"></i> 第2章-Java内存区域与内存溢出异常
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/20/%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E3%80%81%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/" rel="next" title="第4章-虚拟机性能监控、故障处理工具">
      第4章-虚拟机性能监控、故障处理工具 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB"><span class="nav-number">1.</span> <span class="nav-text">对象已死?</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">再谈引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1"><span class="nav-number">1.4.</span> <span class="nav-text">生存还是死亡?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.5.</span> <span class="nav-text">回收方法区</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="nav-number">2.1.</span> <span class="nav-text">分代收集理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">标记-复制算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">2.4.</span> <span class="nav-text">标记-整理算法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HotSpot%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">HotSpot算法细节实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E7%BB%93%E7%82%B9%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.1.</span> <span class="nav-text">根结点枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="nav-number">3.2.</span> <span class="nav-text">安全点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">3.3.</span> <span class="nav-text">安全区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86%E4%B8%8E%E5%8D%A1%E8%A1%A8"><span class="nav-number">3.4.</span> <span class="nav-text">记忆集与卡表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">3.5.</span> <span class="nav-text">写屏障</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">3.6.</span> <span class="nav-text">并发的可达性分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">经典垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.4.</span> <span class="nav-text">Serial Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.6.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Garbage-First%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.7.</span> <span class="nav-text">Garbage First收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shenandoah%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.8.</span> <span class="nav-text">Shenandoah收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Brooks-Pointer"><span class="nav-number">4.8.1.</span> <span class="nav-text">Brooks Pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ZGC%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">4.9.</span> <span class="nav-text">ZGC收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88-Colored-Pointer%E3%80%81Tag-Pointer%E3%80%81Version-Pointer"><span class="nav-number">4.9.1.</span> <span class="nav-text">染色指针 (Colored Pointer、Tag Pointer、Version Pointer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.9.2.</span> <span class="nav-text">执行步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="nav-number">4.9.3.</span> <span class="nav-text">优劣势</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.</span> <span class="nav-text">选择合适的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Epsilon%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">5.1.</span> <span class="nav-text">Epsilon收集器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="nav-number">5.2.</span> <span class="nav-text">收集器的权衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%97%A5%E5%BF%97"><span class="nav-number">5.3.</span> <span class="nav-text">虚拟机及垃圾收集器日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93"><span class="nav-number">5.4.</span> <span class="nav-text">垃圾收集器参数总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E6%88%98-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">6.</span> <span class="nav-text">实战: 内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">6.1.</span> <span class="nav-text">对象优先在Eden区分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">6.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">6.3.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="nav-number">6.4.</span> <span class="nav-text">动态对象年龄判定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">6.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Max"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Max</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dongrongyu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dongrongyu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rongyu.dong@gmail.com" title="E-Mail → mailto:rongyu.dong@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Max</span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : '3nDJCTt3PoQ9qeabywtgL5qQ-gzGzoHsz',
      appKey     : 'HMGLSYCgLRuL0Tst8VMocAfj',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
